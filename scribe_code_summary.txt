

######## Scribe/ContentView.swift ########

//
//  ContentView.swift
//  Scribe
//
//  Created by Ruben Reut on 14/04/2025.
//

import SwiftUI
import SwiftData
import Foundation

/// Main content view showing split navigation between note list and editor
struct ContentView: View {
    @Environment(\.modelContext) private var modelContext
    @State private var viewModel: NoteViewModel
    // Always use rich text - remove toggle functionality
    private let useRichText: Bool = true
    
    init() {
        // This will be properly initialized when the @Environment is available
        do {
            let container = try ModelContainer(for: ScribeNote.self)
            _viewModel = State(initialValue: NoteViewModel(modelContext: ModelContext(container)))
        } catch {
            fatalError("Failed to create model container: \(error.localizedDescription)")
        }
    }
    
    var body: some View {
        NavigationSplitView {
            VStack {
                NoteListView(
                    notes: viewModel.filteredNotes,
                    selectedNote: $viewModel.selectedNote,
                    onDelete: viewModel.deleteNotes,
                    viewModel: viewModel
                )
                .searchable(text: $viewModel.searchText, prompt: "Search notes...")
                .navigationTitle("Notes")
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button(action: viewModel.createNewNote) {
                            Label("New Note", systemImage: "square.and.pencil")
                                .accessibilityLabel("Create a new note")
                        }
                    }
                    
                    
                    // Rich text toggle button removed - always using rich text editor
                }
            }
        } detail: {
            // Only show the rich text editor
            RichTextNoteEditorView(selectedNote: $viewModel.selectedNote, viewModel: viewModel)
        }
        .navigationSplitViewStyle(.balanced)
        .onAppear {
            // Replace the temporary context with the real one
            viewModel = NoteViewModel(modelContext: modelContext)
            
            // Refresh notes on appear to ensure we have the latest data
            viewModel.refreshNotes()
        }
        .onReceive(NotificationCenter.default.publisher(for: Constants.NotificationNames.createNewNote)) { _ in
            viewModel.createNewNote()
        }
    }
}

#Preview {
    @MainActor func createPreview() -> some View {
        let container = try! ModelContainer(for: ScribeNote.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))
        
        return ContentView()
            .modelContainer(container)
    }
    
    return createPreview()
}


######## Scribe/Model/Note.swift ########

import Foundation
import SwiftData
import SwiftUI

/// Represents a note in the Scribe application
@Model
final class ScribeNote {
    var title: String
    var content: Data
    var createdAt: Date
    var lastModified: Date
    
    /// Creates a new note with optional parameters
    /// - Parameters:
    ///   - title: The title of the note
    ///   - content: The content as binary data (for attributed string)
    ///   - createdAt: The creation date (defaults to now)
    ///   - lastModified: The last modification date (defaults to now)
    init(title: String = "New Note", content: Data = Data(), createdAt: Date = Date(), lastModified: Date = Date()) {
        self.title = title
        self.content = content
        self.createdAt = createdAt
        self.lastModified = lastModified
    }
}

extension ScribeNote: Equatable {
    static func == (lhs: ScribeNote, rhs: ScribeNote) -> Bool {
        lhs.persistentModelID == rhs.persistentModelID
    }
}

######## Scribe/ScribeApp.swift ########

//
//  ScribeApp.swift
//  Scribe
//
//  Created by Ruben Reut on 14/04/2025.
//

import SwiftUI
import SwiftData
import OSLog
import Foundation

/// Main application entry point
@main
struct ScribeApp: App {
    private let logger = Logger(subsystem: "com.rubenreut.Scribe", category: "Application")
    
    init() {
        configureLogger()
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                // No need to log every view appearance
        }
        .modelContainer(for: ScribeNote.self)
        .commands {
            // Add app-specific commands
            CommandGroup(after: .newItem) {
                Button("New Note") {
                    NotificationCenter.default.post(name: Constants.NotificationNames.createNewNote, object: nil)
                }
                .keyboardShortcut("n", modifiers: [.command])
            }
        }
    }
    
    /// Configures application-wide logging
    private func configureLogger() {
        #if DEBUG
        // More verbose in debug builds
        // Debug logging enabled
        #endif
    }
}



######## Scribe/Utilities/Constants.swift ########

import Foundation

/// Application-wide constants
enum Constants {
    /// Notification names used throughout the app
    enum NotificationNames {
        /// Notification posted when a new note should be created
        static let createNewNote = Notification.Name("CreateNewNote")
    }
    
    /// Time constants
    enum Time {
        /// Autosave delay in milliseconds
        static let autosaveDelay: UInt64 = 500
    }
}

######## Scribe/Utilities/ViewExtensions.swift ########

import SwiftUI
import UIKit

/// Extensions to SwiftUI View for common functionality
extension View {
    /// Hides the keyboard by resigning first responder
    func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
}

######## Scribe/View/AttachmentMenu.swift ########

import SwiftUI
import UniformTypeIdentifiers
import PhotosUI

/// A menu for attaching different types of content to notes
struct AttachmentMenu: View {
    @Binding var showImagePicker: Bool
    @Binding var showDocumentPicker: Bool
    
    var body: some View {
        Menu {
            Button(action: { showImagePicker = true }) {
                Label("Photo", systemImage: "photo")
            }
            
            Button(action: { showDocumentPicker = true }) {
                Label("Document", systemImage: "doc")
            }
            
            // Camera option - would require camera permission handling
            Button(action: { /* Camera handling would go here */ }) {
                Label("Camera", systemImage: "camera")
            }
            
            // Scan document option
            Button(action: { /* Document scanning would go here */ }) {
                Label("Scan Document", systemImage: "doc.viewfinder")
            }
        } label: {
            Image(systemName: "paperclip")
                .font(.system(size: 17, weight: .semibold))
                .frame(width: 34, height: 34)
                .background(Color.secondary.opacity(0.1))
                .clipShape(Circle())
        }
    }
}

// Preview provider for design-time preview
struct AttachmentMenu_Previews: PreviewProvider {
    static var previews: some View {
        AttachmentMenu(
            showImagePicker: .constant(false),
            showDocumentPicker: .constant(false)
        )
        .previewLayout(.sizeThatFits)
        .padding()
    }
}

######## Scribe/View/DocumentPicker.swift ########

import SwiftUI
import UniformTypeIdentifiers
import UIKit

struct DocumentPicker: UIViewControllerRepresentable {
    @Environment(\.presentationMode) var presentationMode
    var completion: (URL) -> Void
    
    func makeUIViewController(context: Context) -> UIDocumentPickerViewController {
        // Allow all document types
        let supportedTypes: [UTType] = [.pdf, .plainText, .image, .audio, .movie, .spreadsheet, .presentation]
        let picker = UIDocumentPickerViewController(forOpeningContentTypes: supportedTypes)
        picker.allowsMultipleSelection = false
        picker.delegate = context.coordinator
        return picker
    }
    
    func updateUIViewController(_ uiViewController: UIDocumentPickerViewController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UIDocumentPickerDelegate {
        let parent: DocumentPicker
        
        init(_ parent: DocumentPicker) {
            self.parent = parent
        }
        
        func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
            guard let url = urls.first else { return }
            
            // Start accessing the security-scoped resource
            let gotAccess = url.startAccessingSecurityScopedResource()
            
            if gotAccess {
                parent.completion(url)
                // Make sure you release the security-scoped resource when finished
                DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                    url.stopAccessingSecurityScopedResource()
                }
            }
            
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
}

######## Scribe/View/FormatMenu.swift ########

import SwiftUI

/// A modern formatting menu for the rich text editor
struct FormatMenu: View {
    @ObservedObject var formattingState: FormattingState
    let onFormat: (FormatAction) -> Void
    
    // Available formatting actions
    enum FormatAction {
        case bold
        case italic
        case underline
        case heading(Font.TextStyle)
        case textColor
        case bulletList
        case clearFormatting
    }
    
    var body: some View {
        Menu {
            // Text style section
            Section {
                Button(action: { onFormat(.bold) }) {
                    Label("Bold", systemImage: "bold")
                }
                .foregroundColor(formattingState.isBold ? .accentColor : nil)
                
                Button(action: { onFormat(.italic) }) {
                    Label("Italic", systemImage: "italic")
                }
                .foregroundColor(formattingState.isItalic ? .accentColor : nil)
                
                Button(action: { onFormat(.underline) }) {
                    Label("Underline", systemImage: "underline")
                }
                .foregroundColor(formattingState.isUnderlined ? .accentColor : nil)
            }
            
            // Headings section
            Section {
                Button(action: { onFormat(.heading(.title)) }) {
                    Label("Heading", systemImage: "textformat.size.larger")
                }
                
                Button(action: { onFormat(.heading(.headline)) }) {
                    Label("Subheading", systemImage: "textformat.size")
                }
                
                Button(action: { onFormat(.heading(.body)) }) {
                    Label("Body Text", systemImage: "text.justify")
                }
            }
            
            // Other formatting section
            Section {
                Button(action: { onFormat(.textColor) }) {
                    Label("Text Color", systemImage: "paintpalette")
                }
                
                Button(action: { onFormat(.bulletList) }) {
                    Label("Bullet List", systemImage: "list.bullet")
                }
                
                Button(action: { onFormat(.clearFormatting) }) {
                    Label("Clear Formatting", systemImage: "eraser")
                }
            }
        } label: {
            Image(systemName: "textformat")
                .font(.system(size: 17, weight: .semibold))
                .frame(width: 34, height: 34)
                .background(Color.secondary.opacity(0.1))
                .clipShape(Circle())
        }
    }
}

// Preview provider for design-time preview
struct FormatMenu_Previews: PreviewProvider {
    static var previews: some View {
        FormatMenu(
            formattingState: FormattingState(),
            onFormat: { _ in }
        )
        .previewLayout(.sizeThatFits)
        .padding()
    }
}

######## Scribe/View/ImagePicker.swift ########

import SwiftUI
import PhotosUI

struct ImagePicker: UIViewControllerRepresentable {
    @Environment(\.presentationMode) var presentationMode
    var completion: (UIImage) -> Void

    func makeUIViewController(context: Context) -> PHPickerViewController {
        var config = PHPickerConfiguration()
        config.filter = .images
        config.selectionLimit = 1
        let picker = PHPickerViewController(configuration: config)
        picker.delegate = context.coordinator
        return picker
    }

    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}

    func makeCoordinator() -> Coordinator {
        Coordinator(parent: self)
    }

    class Coordinator: NSObject, PHPickerViewControllerDelegate {
        var parent: ImagePicker

        init(parent: ImagePicker) {
            self.parent = parent
        }

        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
            picker.dismiss(animated: true)
            guard let provider = results.first?.itemProvider,
                  provider.canLoadObject(ofClass: UIImage.self) else { return }

            provider.loadObject(ofClass: UIImage.self) { image, _ in
                if let uiImage = image as? UIImage {
                    DispatchQueue.main.async {
                        self.parent.completion(uiImage)
                    }
                }
            }
        }
    }
}

######## Scribe/View/NoteEditorView.swift ########

import SwiftUI
import SwiftData
import OSLog
// Import view extensions
import UIKit

/// View for editing a single note
struct NoteEditorView: View {
    @Binding var note: ScribeNote?
    let viewModel: NoteViewModel
    private let logger = Logger(subsystem: "com.rubenreut.Scribe", category: "NoteEditorView")
    
    @Environment(\.undoManager) private var undoManager
    
    var body: some View {
        Group {
            if let note = note {
                VStack(spacing: 0) {
                    TextField("Title", text: Binding(
                        get: { note.title },
                        set: { newValue in
                            viewModel.updateNoteTitle(note, newTitle: newValue)
                        }
                    ))
                    .font(.largeTitle)
                    .padding([.horizontal, .top])
                    .textFieldStyle(.plain)
                    .accessibilityIdentifier("note-title-field")
                    
                    Divider()
                        .padding(.horizontal)
                    
                    TextEditor(text: Binding(
                        get: { 
                            // Get plain text from the attributed string
                            return viewModel.attributedContent(for: note).string
                        },
                        set: { newValue in
                            // Create a simple attributed string from plain text
                            let attributedString = NSAttributedString(string: newValue)
                            viewModel.updateNoteContent(note, newContent: attributedString)
                        }
                    ))
                    .font(.body)
                    .scrollContentBackground(.hidden)
                    .background(Color(.systemBackground))
                    .padding()
                    .accessibilityIdentifier("note-content-field")
                    
                    HStack {
                        Spacer()
                        Text("Last edited: \(note.lastModified, style: .relative)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .padding(.horizontal)
                            .accessibilityLabel("Last edited \(note.lastModified.formatted())")
                    }
                    .padding(.bottom, 4)
                }
                .toolbar {
                    ToolbarItemGroup(placement: .keyboard) {
                        Spacer()
                        
                        Button("Done") {
                            hideKeyboard()
                        }
                        .accessibilityIdentifier("keyboard-done-button")
                    }
                    
                    ToolbarItemGroup(placement: .primaryAction) {
                        if let undoManager = undoManager {
                            Button {
                                undoManager.undo()
                            } label: {
                                Label("Undo", systemImage: "arrow.uturn.backward")
                            }
                            .disabled(!undoManager.canUndo)
                            
                            Button {
                                undoManager.redo()
                            } label: {
                                Label("Redo", systemImage: "arrow.uturn.forward")
                            }
                            .disabled(!undoManager.canRedo)
                        }
                    }
                }
            } else {
                ContentUnavailableView(
                    label: {
                        Label("No Note Selected", systemImage: "square.and.pencil")
                    },
                    description: {
                        Text("Select a note from the list or create a new one.")
                    }
                )
            }
        }
        .task(id: note?.persistentModelID) {
            // No need to log routine view appearance
        }
    }
    
    // Using View extension for keyboard dismissal
}

#Preview {
    @MainActor func createPreview() -> some View {
        let container = try! ModelContainer(for: ScribeNote.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))
        let modelContext = container.mainContext
        let viewModel = NoteViewModel(modelContext: modelContext)
        
        // Create an attributed string
        let attributedString = NSAttributedString(string: "This is sample content")
        
        // Create sample note with archived attributed string
        let sampleNote = ScribeNote(title: "Sample Note")
        if let data = try? NSKeyedArchiver.archivedData(withRootObject: attributedString, requiringSecureCoding: true) {
            sampleNote.content = data
        }
        modelContext.insert(sampleNote)
        
        return NoteEditorView(note: .constant(sampleNote), viewModel: viewModel)
            .modelContainer(container)
    }
    
    return createPreview()
}


######## Scribe/View/NoteListView.swift ########

import SwiftUI
import SwiftData

/// List view showing all notes
struct NoteListView: View {
    var notes: [ScribeNote]
    @Binding var selectedNote: ScribeNote?
    var onDelete: (IndexSet) -> Void
    let viewModel: NoteViewModel
    
    var body: some View {
        List(selection: $selectedNote) {
            ForEach(notes) { note in
                NoteRowView(note: note, viewModel: viewModel)
                    .tag(note)
                    .contextMenu {
                        Button(role: .destructive) {
                            if let index = notes.firstIndex(where: { $0 == note }) {
                                onDelete(IndexSet(integer: index))
                            }
                        } label: {
                            Label("Delete", systemImage: "trash")
                        }
                    }
            }
            .onDelete(perform: onDelete)
        }
        .listStyle(.sidebar)
        .navigationTitle("Notes")
        .scrollContentBackground(.visible)
        .accessibilityLabel("Notes list")
    }
}

/// Individual row in the notes list
struct NoteRowView: View {
    let note: ScribeNote
    let viewModel: NoteViewModel
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(note.title)
                .font(.headline)
                .lineLimit(1)
                .accessibilityAddTraits(.isHeader)
            
            Text(note.lastModified, style: .relative)
                .font(.caption)
                .foregroundColor(.secondary)
                .accessibilityLabel("Last edited \(note.lastModified.formatted())")
            
            Text(viewModel.attributedContent(for: note).string)
                .font(.caption)
                .foregroundColor(.secondary)
                .lineLimit(2)
                .accessibilityLabel("Note preview: \(viewModel.attributedContent(for: note).string)")
        }
        .padding(.vertical, 4)
    }
}

#Preview {
    @MainActor func createPreview() -> some View {
        let container = try! ModelContainer(for: ScribeNote.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))
        let modelContext = container.mainContext
        let viewModel = NoteViewModel(modelContext: modelContext)
        
        // Create an attributed string
        let attributedString = NSAttributedString(string: "This is sample content")
        
        // Create sample note with archived attributed string
        let sampleNote = ScribeNote(title: "Sample Note")
        if let data = try? NSKeyedArchiver.archivedData(withRootObject: attributedString, requiringSecureCoding: true) {
            sampleNote.content = data
        }
        modelContext.insert(sampleNote)
        
        return NoteListView(
            notes: [sampleNote],
            selectedNote: .constant(sampleNote),
            onDelete: { _ in },
            viewModel: viewModel
        )
        .modelContainer(container)
    }
    
    return createPreview()
}



######## Scribe/View/RichTextEditor.swift ########

import SwiftUI
import UIKit

/// A formatting state class to hold the current styling state
class FormattingState: ObservableObject {
    @Published var isBold: Bool = false
    @Published var isItalic: Bool = false
    @Published var isUnderlined: Bool = false
    @Published var textColor: Color = .primary
}

/// A SwiftUI wrapper around UITextView for rich text editing
struct RichTextEditor: UIViewRepresentable {
    @Binding var attributedText: NSAttributedString
    var onTextChange: (NSAttributedString) -> Void
    
    // Formatting state (shared with toolbar)
    @ObservedObject var formattingState: FormattingState
    
    // Configuration options
    var backgroundColor: UIColor = .systemBackground
    var tintColor: UIColor = .label
    
    func makeUIView(context: Context) -> UITextView {
        let textView = UITextView()
        textView.delegate = context.coordinator
        textView.backgroundColor = backgroundColor
        textView.tintColor = tintColor
        
        // Use body text as default styling
        let bodyFont = UIFont.preferredFont(forTextStyle: .body)
        textView.font = bodyFont
        
        // Set default typing attributes for consistent formatting
        textView.typingAttributes = [
            .font: bodyFont,
            .foregroundColor: UIColor.label
        ]
        
        // Configure text view behavior
        textView.isScrollEnabled = true
        textView.isEditable = true
        textView.isUserInteractionEnabled = true
        textView.autocapitalizationType = .sentences
        textView.autocorrectionType = .default
        textView.allowsEditingTextAttributes = true
        textView.dataDetectorTypes = [.link]
        textView.isSelectable = true
        
        // Improve performance by setting these properties
        textView.layoutManager.allowsNonContiguousLayout = false
        textView.textContainerInset = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)
        
        // Ensure content text is applied before setting references
        if attributedText.length > 0 {
            textView.attributedText = attributedText
        } else {
            // If there's no text, create an empty attributed string with body formatting
            textView.attributedText = NSAttributedString(
                string: "",
                attributes: [.font: bodyFont, .foregroundColor: UIColor.label]
            )
        }
        
        // Important: Set this in the coordinator
        context.coordinator.textView = textView
        
        // Store reference in the shared holder immediately
        DispatchQueue.main.async {
            RichTextViewHolder.shared.textView = textView
        }
        
        return textView
    }
    
    func updateUIView(_ textView: UITextView, context: Context) {
        // Only update if the text has actually changed to prevent unnecessary refreshes
        let textViewString = textView.attributedText.string
        let newString = attributedText.string
        
        if textViewString != newString || textView.attributedText.length != attributedText.length {
            // Save cursor position and selection state
            let selectedRange = textView.selectedRange
            let isFirstResponder = textView.isFirstResponder
            
            // Disable delegate temporarily to prevent unwanted calls
            let oldDelegate = textView.delegate
            textView.delegate = nil
            
            // Update the text
            textView.attributedText = attributedText
            
            // Re-enable delegate
            textView.delegate = oldDelegate
            
            // Restore cursor position with thorough bounds checking
            if NSLocationInRange(selectedRange.location, NSRange(location: 0, length: attributedText.length)) {
                textView.selectedRange = selectedRange
            } else if attributedText.length > 0 {
                // If cursor was outside valid range, place at end of text
                textView.selectedRange = NSRange(location: min(selectedRange.location, attributedText.length), length: 0)
            } else {
                textView.selectedRange = NSRange(location: 0, length: 0)
            }
            
            // Make sure first responder state is preserved
            if isFirstResponder && !textView.isFirstResponder {
                textView.becomeFirstResponder()
            }
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UITextViewDelegate {
        var parent: RichTextEditor
        var textView: UITextView?
        
        init(_ parent: RichTextEditor) {
            self.parent = parent
        }
        
        func textViewDidChange(_ textView: UITextView) {
            self.textView = textView
            
            // Create non-mutable copy of the text to avoid reference issues
            let textCopy = NSAttributedString(attributedString: textView.attributedText)
            
            // Optimize for large content changes
            let shouldDelayUpdate = textView.text.count > 1000
                                
            // For smaller content, update immediately
            if !shouldDelayUpdate {
                self.parent.attributedText = textCopy
                self.parent.onTextChange(textCopy)
            } else {
                // For larger content, batch updates with slight delay to prevent lag
                DispatchQueue.main.async { [weak self] in
                    guard let self = self else { return }
                    self.parent.attributedText = textCopy
                    self.parent.onTextChange(textCopy)
                }
            }
        }
        
        // Add this to ensure styling is preserved when view appears/reappears
        func textViewDidEndEditing(_ textView: UITextView) {
            // Save the final attributed text when editing ends
            let textCopy = NSAttributedString(attributedString: textView.attributedText)
            self.parent.attributedText = textCopy
            self.parent.onTextChange(textCopy)
        }
        
        // Method to insert images into the rich text
        func insertImage(_ image: UIImage) {
            guard let textView = self.textView else { return }
            
            // Create the NSTextAttachment
            let attachment = NSTextAttachment()
            attachment.image = image
            
            // Adjust attachment bounds (resize if necessary)
            let maxWidth = textView.frame.size.width - 20
            let imageRatio = image.size.height / image.size.width
            let attachmentWidth = min(maxWidth, image.size.width)
            let attachmentHeight = attachmentWidth * imageRatio
            attachment.bounds = CGRect(x: 0, y: 0, width: attachmentWidth, height: attachmentHeight)

            // Create attributed string from attachment
            let attrStringWithImage = NSAttributedString(attachment: attachment)

            // Insert at the current cursor location
            let mutableAttrString = NSMutableAttributedString(attributedString: textView.attributedText)
            let selectedRange = textView.selectedRange
            mutableAttrString.insert(attrStringWithImage, at: selectedRange.location)

            // Update textView
            textView.attributedText = mutableAttrString
            
            // Move cursor after the inserted image
            textView.selectedRange = NSRange(location: selectedRange.location + 1, length: 0)
            
            // Notify parent SwiftUI view about changes
            parent.attributedText = textView.attributedText
            parent.onTextChange(textView.attributedText)
        }
        
        // Method to insert a document reference/link
        func insertDocumentLink(url: URL, filename: String) {
            guard let textView = self.textView else { return }
            
            // Create a link text with the file name
            let linkText = " 📎 \(filename) "
            
            // Create an attributed string with a link
            let linkAttributes: [NSAttributedString.Key: Any] = [
                .link: url,
                .foregroundColor: UIColor.systemBlue,
                .underlineStyle: NSUnderlineStyle.single.rawValue,
                .backgroundColor: UIColor.systemGray6
            ]
            
            let linkString = NSAttributedString(string: linkText, attributes: linkAttributes)
            
            // Insert at the current cursor location
            let mutableAttrString = NSMutableAttributedString(attributedString: textView.attributedText)
            let selectedRange = textView.selectedRange
            mutableAttrString.insert(linkString, at: selectedRange.location)
            
            // Update textView
            textView.attributedText = mutableAttrString
            
            // Move cursor after the inserted link
            textView.selectedRange = NSRange(location: selectedRange.location + linkText.count, length: 0)
            
            // Notify parent SwiftUI view about changes
            parent.attributedText = textView.attributedText
            parent.onTextChange(textView.attributedText)
        }
        
        // Update toolbar state based on cursor position
        func textViewDidChangeSelection(_ textView: UITextView) {
            self.textView = textView
            
            // Throttle updates to formatting state to prevent lag
            // Only update if selection is stable
            let currentSelection = textView.selectedRange
            let shouldUpdateFormatting = currentSelection.location != 0 || currentSelection.length > 0
            
            // Update the shared text view holder outside the main state update
            // to prevent performance issues
            RichTextViewHolder.shared.textView = textView
            
            // Don't update formatting state if text is empty
            if textView.text.isEmpty {
                self.resetFormattingState()
                return
            }
            
            // We only want to update if we have a valid position that makes sense to check
            if shouldUpdateFormatting {
                DispatchQueue.main.async { [weak self] in
                    guard let self = self, 
                          let textView = self.textView,
                          textView.selectedRange == currentSelection else { return }
                    
                    self.updateFormattingState(for: textView)
                }
            }
        }
        
        // Helper to update formatting state without duplicating code
        private func updateFormattingState(for textView: UITextView) {
            let cursorPosition = textView.selectedRange.location
            let selectionLength = textView.selectedRange.length
            
            // If we have a selection, check the attributes of the first character
            if selectionLength > 0 && textView.attributedText.length > cursorPosition {
                self.updateFormattingFromAttributes(
                    textView.textStorage.attributes(at: cursorPosition, effectiveRange: nil)
                )
            }
            // If we have just a cursor and it's not at the start, check character to the left
            else if selectionLength == 0 && cursorPosition > 0 && textView.attributedText.length >= cursorPosition {
                self.updateFormattingFromAttributes(
                    textView.textStorage.attributes(at: cursorPosition - 1, effectiveRange: nil)
                )
            }
            // If at beginning of text, check typing attributes for future input
            else {
                self.updateFormattingFromAttributes(textView.typingAttributes)
            }
        }
        
        // Helper to update the format state from attributes dictionary
        private func updateFormattingFromAttributes(_ attributes: [NSAttributedString.Key: Any]) {
            // Check for font traits
            if let font = attributes[.font] as? UIFont {
                self.parent.formattingState.isBold = font.fontDescriptor.symbolicTraits.contains(.traitBold)
                self.parent.formattingState.isItalic = font.fontDescriptor.symbolicTraits.contains(.traitItalic)
            } else {
                // Default state if no font
                self.parent.formattingState.isBold = false
                self.parent.formattingState.isItalic = false
            }
            
            // Check for underline
            self.parent.formattingState.isUnderlined = attributes[.underlineStyle] != nil
            
            // Update text color if present
            if let color = attributes[.foregroundColor] as? UIColor {
                self.parent.formattingState.textColor = Color(color)
            } else {
                self.parent.formattingState.textColor = .primary
            }
        }
        
        // Reset formatting state to defaults
        private func resetFormattingState() {
            self.parent.formattingState.isBold = false
            self.parent.formattingState.isItalic = false
            self.parent.formattingState.isUnderlined = false
            self.parent.formattingState.textColor = .primary
        }
    }
}

/// A toolbar for rich text editing actions
struct RichTextToolbar: View {
    // Singleton instance for external access
    static var shared: RichTextToolbar?
    
    @Binding var attributedText: NSAttributedString
    let textView: UITextView?  // Reference to the active UITextView
    
    // Shared formatting state
    @ObservedObject var formattingState: FormattingState
    
    init(attributedText: Binding<NSAttributedString>, textView: UITextView?, formattingState: FormattingState) {
        self._attributedText = attributedText
        self.textView = textView
        self.formattingState = formattingState
        
        // Set shared instance
        Self.shared = self
    }
    
    var body: some View {
        // We're not displaying the traditional toolbar in the new UI design
        // But we need to keep the toolbar structure for the formatting methods
        Color.clear.frame(width: 0, height: 0)
            .accessibilityHidden(true)
            .id(1000) // Add a tag that can be found for direct method access
            .sheet(isPresented: $showColorPickerVisible) {
                ColorPicker("Text Color", selection: $formattingState.textColor)
                    .padding()
                    .onChange(of: formattingState.textColor) { [self] _ in
                        self.applyTextColor()
                    }
                    .presentationDetents([.height(200)])
            }
    }
    
    // State for color picker sheet
    @State private var showColorPickerVisible = false
    
    // Apply bold formatting
    func toggleBold() {
        formattingState.isBold.toggle()
        
        guard let textView = textView else { return }

        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            // Scenario: User has selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            
            // Store the original selection to restore it later
            let originalSelection = textView.selectedRange
            
            // Using a more efficient approach with fewer iterations
            let fullRange = NSRange(location: 0, length: mutableAttrText.length)
            mutableAttrText.enumerateAttribute(.font, in: selectedRange, options: []) { value, range, _ in
                let currentFont = value as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
                var traits = currentFont.fontDescriptor.symbolicTraits
                
                // Update traits based on formatting state
                if formattingState.isBold {
                    traits.insert(.traitBold)
                } else {
                    traits.remove(.traitBold)
                }
                
                // Create new font with updated traits
                if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                    let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                    
                    // Collect other existing attributes at this range to preserve them
                    var combinedAttributes: [NSAttributedString.Key: Any] = [.font: newFont]
                    
                    // Add other existing attributes
                    mutableAttrText.attributes(at: range.location, effectiveRange: nil).forEach { key, value in
                        if key != .font {
                            combinedAttributes[key] = value
                        }
                    }
                    
                    // Apply all attributes at once
                    mutableAttrText.addAttributes(combinedAttributes, range: range)
                }
            }
            
            // Update the text and restore selection
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            
            // Ensure selection is within bounds
            if NSLocationInRange(originalSelection.location, NSRange(location: 0, length: mutableAttrText.length)) {
                textView.selectedRange = originalSelection
            } else {
                textView.selectedRange = NSRange(location: mutableAttrText.length, length: 0)
            }
        } else {
            // Scenario: No selection; set typing attributes for future input
            var currentAttributes = textView.typingAttributes
            let currentFont = currentAttributes[.font] as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
            var traits = currentFont.fontDescriptor.symbolicTraits

            if formattingState.isBold {
                traits.insert(.traitBold)
            } else {
                traits.remove(.traitBold)
            }

            if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                currentAttributes[.font] = newFont
                textView.typingAttributes = currentAttributes
            }
        }
    }
    
    // Apply italic formatting
    func toggleItalic() {
        formattingState.isItalic.toggle()
        
        guard let textView = textView else { return }

        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            // Scenario: User has selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            
            mutableAttrText.enumerateAttribute(.font, in: selectedRange) { value, range, _ in
                let currentFont = value as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
                var traits = currentFont.fontDescriptor.symbolicTraits
                
                if formattingState.isItalic {
                    traits.insert(.traitItalic)
                } else {
                    traits.remove(.traitItalic)
                }
                
                if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                    let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                    mutableAttrText.addAttribute(.font, value: newFont, range: range)
                }
            }
            
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            textView.selectedRange = selectedRange
        } else {
            // Scenario: No selection; set typing attributes for future input
            var currentAttributes = textView.typingAttributes
            let currentFont = currentAttributes[.font] as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
            var traits = currentFont.fontDescriptor.symbolicTraits

            if formattingState.isItalic {
                traits.insert(.traitItalic)
            } else {
                traits.remove(.traitItalic)
            }

            if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                currentAttributes[.font] = newFont
                textView.typingAttributes = currentAttributes
            }
        }
    }
    
    // Apply underline formatting
    func toggleUnderline() {
        formattingState.isUnderlined.toggle()
        
        guard let textView = textView else { return }
        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            // Scenario: User has selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            
            if formattingState.isUnderlined {
                mutableAttrText.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: selectedRange)
            } else {
                mutableAttrText.removeAttribute(.underlineStyle, range: selectedRange)
            }
            
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            textView.selectedRange = selectedRange
        } else {
            // Scenario: No selection; set typing attributes for future input
            var currentAttributes = textView.typingAttributes
            
            if formattingState.isUnderlined {
                currentAttributes[.underlineStyle] = NSUnderlineStyle.single.rawValue
            } else {
                currentAttributes.removeValue(forKey: .underlineStyle)
            }
            
            textView.typingAttributes = currentAttributes
        }
    }
    
    // Apply text color
    func applyTextColor() {
        guard let textView = textView else { return }
        let selectedRange = textView.selectedRange
        let uiColor = UIColor(formattingState.textColor)
        
        if selectedRange.length > 0 {
            // Scenario: User has selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            
            // More efficient to add all attributes at once if possible
            var attributes: [NSAttributedString.Key: Any] = [.foregroundColor: uiColor]
            
            // Include font attributes if they exist at this position
            if let existingFont = mutableAttrText.attribute(.font, at: selectedRange.location, effectiveRange: nil) as? UIFont {
                attributes[.font] = existingFont
            }
            
            mutableAttrText.addAttributes(attributes, range: selectedRange)
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            textView.selectedRange = selectedRange
        } else {
            // Scenario: No selection; set typing attributes for future input
            var currentAttributes = textView.typingAttributes
            currentAttributes[.foregroundColor] = uiColor
            textView.typingAttributes = currentAttributes
        }
    }
    
    // Apply heading format
    func applyHeading(_ style: Font.TextStyle) {
        guard let textView = textView else { return }
        let selectedRange = textView.selectedRange
        
        // Determine font size based on heading style
        let fontSize: CGFloat
        switch style {
        case .title: fontSize = 24
        case .headline: fontSize = 18
        default: fontSize = 16
        }
        
        let fontWeight = style == .body ? UIFont.Weight.regular : UIFont.Weight.bold
        let newFont = UIFont.systemFont(ofSize: fontSize, weight: fontWeight)
        
        if selectedRange.length > 0 {
            // Scenario: User has selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            
            // Preserve bold/italic traits if present
            mutableAttrText.enumerateAttribute(.font, in: selectedRange) { value, range, _ in
                if let currentFont = value as? UIFont {
                    var traits = currentFont.fontDescriptor.symbolicTraits
                    if let descriptor = newFont.fontDescriptor.withSymbolicTraits(traits) {
                        let styledFont = UIFont(descriptor: descriptor, size: fontSize)
                        mutableAttrText.addAttribute(.font, value: styledFont, range: range)
                    } else {
                        mutableAttrText.addAttribute(.font, value: newFont, range: range)
                    }
                } else {
                    mutableAttrText.addAttribute(.font, value: newFont, range: range)
                }
            }
            
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            textView.selectedRange = selectedRange
        } else {
            // Scenario: No selection; set typing attributes for future input
            var currentAttributes = textView.typingAttributes
            currentAttributes[.font] = newFont
            textView.typingAttributes = currentAttributes
            
            // Update toolbar state for this font size/style
            formattingState.isBold = fontWeight == .bold
        }
    }
    
    // Apply bullet points more efficiently using paragraph style
    func applyBulletPoints() {
        guard let textView = textView else { return }
        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            // Processing selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            let fullText = mutableAttrText.string
            
            // Get the paragraph ranges from the selection
            let nsString = fullText as NSString
            let paragraphRange = nsString.paragraphRange(for: selectedRange)
            
            // Create paragraph style with indentation
            let paragraphStyle = NSMutableParagraphStyle()
            paragraphStyle.headIndent = 15
            paragraphStyle.firstLineHeadIndent = 0
            paragraphStyle.paragraphSpacing = 4
            
            // Split the selected text into paragraphs and process each one
            let selectedText = nsString.substring(with: paragraphRange)
            let paragraphs = selectedText.components(separatedBy: "\n")
            var bulletedText = ""
            
            for (index, paragraph) in paragraphs.enumerated() {
                let trimmedParagraph = paragraph.trimmingCharacters(in: .whitespacesAndNewlines)
                if !trimmedParagraph.isEmpty {
                    let bulletedParagraph = "• " + paragraph
                    bulletedText += bulletedParagraph
                    if index < paragraphs.count - 1 || selectedText.hasSuffix("\n") {
                        bulletedText += "\n"
                    }
                } else if index < paragraphs.count - 1 {
                    bulletedText += "\n"
                }
            }
            
            // Apply the formatted text with attributes while preserving existing attributes
            let bulletedAttrString = NSMutableAttributedString(string: bulletedText)
            
            // Apply paragraph style to the entire text
            bulletedAttrString.addAttribute(.paragraphStyle, value: paragraphStyle, range: NSRange(location: 0, length: bulletedText.count))
            
            // Copy other attributes from original text
            let originalAttrs = mutableAttrText.attributes(at: paragraphRange.location, effectiveRange: nil)
            for (key, value) in originalAttrs {
                if key != .paragraphStyle {
                    bulletedAttrString.addAttribute(key, value: value, range: NSRange(location: 0, length: bulletedText.count))
                }
            }
            
            mutableAttrText.replaceCharacters(in: paragraphRange, with: bulletedAttrString)
            
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            
            // Set cursor position at the end of the modified text
            let newCursorPosition = paragraphRange.location + bulletedText.count
            textView.selectedRange = NSRange(location: newCursorPosition, length: 0)
        } else {
            // Cursor only - modify current line
            let text = textView.text as NSString
            let currentPosition = selectedRange.location
            let lineRange = text.lineRange(for: NSRange(location: currentPosition, length: 0))
            
            // Create paragraph style with indentation
            let paragraphStyle = NSMutableParagraphStyle()
            paragraphStyle.headIndent = 15
            paragraphStyle.firstLineHeadIndent = 0
            paragraphStyle.paragraphSpacing = 4
            
            // Prepare for typing a bullet point
            var currentAttributes = textView.typingAttributes
            currentAttributes[.paragraphStyle] = paragraphStyle
            textView.typingAttributes = currentAttributes
            
            // Insert bullet at current position
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            let bulletText = "• "
            let bulletAttrs = textView.typingAttributes
            let bulletAttrString = NSAttributedString(string: bulletText, attributes: bulletAttrs)
            
            mutableAttrText.insert(bulletAttrString, at: currentPosition)
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            textView.selectedRange = NSRange(location: currentPosition + bulletText.count, length: 0)
        }
    }
    
    // Clear all formatting
    func clearFormatting() {
        guard let textView = textView else { return }
        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            // Clear formatting on selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            let plainText = mutableAttrText.string.substring(with: Range(selectedRange, in: mutableAttrText.string)!)
            
            // Create an attributed string with default attributes only
            let defaultFont = UIFont.preferredFont(forTextStyle: .body)
            let defaultAttributes: [NSAttributedString.Key: Any] = [
                .font: defaultFont,
                .foregroundColor: UIColor.label
            ]
            let plainAttrString = NSAttributedString(string: plainText, attributes: defaultAttributes)
            
            mutableAttrText.replaceCharacters(in: selectedRange, with: plainAttrString)
            
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            textView.selectedRange = NSRange(location: selectedRange.location, length: plainText.count)
            
            // Reset toolbar state
            formattingState.isBold = false
            formattingState.isItalic = false
            formattingState.isUnderlined = false
            formattingState.textColor = Color.primary
        } else {
            // Reset typing attributes for future input
            let defaultFont = UIFont.preferredFont(forTextStyle: .body)
            let defaultAttributes: [NSAttributedString.Key: Any] = [
                .font: defaultFont,
                .foregroundColor: UIColor.label
            ]
            textView.typingAttributes = defaultAttributes
            
            // Reset toolbar state
            formattingState.isBold = false
            formattingState.isItalic = false
            formattingState.isUnderlined = false
            formattingState.textColor = Color.primary
        }
    }
}

######## Scribe/View/RichTextNoteEditorView.swift ########

import SwiftUI
import UIKit
import SwiftData
import OSLog
import UniformTypeIdentifiers

/// View for editing a note with rich text formatting capabilities
struct RichTextNoteEditorView: View {
    @Binding var selectedNote: ScribeNote?
    let viewModel: NoteViewModel
    @State private var attributedText = NSAttributedString(string: "")
    @ObservedObject private var textViewHolder = RichTextViewHolder.shared
    @StateObject private var formattingState = FormattingState()
    
    // Sheet states for pickers
    @State private var showImagePicker = false
    @State private var showDocumentPicker = false
    @State private var showColorPicker = false
    
    // Add id to force view refreshes when selected note changes
    private var noteId: String {
        selectedNote?.persistentModelID.storeIdentifier ?? "no-note"
    }
    
    private let logger = Logger(subsystem: "com.rubenreut.Scribe", category: "RichTextNoteEditorView")
    
    var body: some View {
        Group {
            if let note = selectedNote {
                VStack(spacing: 0) {
                    // Title field with iOS-style appearance
                    TextField("Title", text: Binding(
                        get: { note.title },
                        set: { newValue in
                            viewModel.updateNoteTitle(note, newTitle: newValue)
                        }
                    ))
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .padding([.horizontal, .top])
                    .textFieldStyle(.plain)
                    .accessibilityIdentifier("note-title-field")
                    
                    HStack {
                        Text(note.lastModified, style: .date)
                            .font(.caption)
                            .foregroundColor(.secondary)
                        Spacer()
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 4)
                    
                    Divider()
                        .padding(.horizontal)
                    
                    // Rich text editor
                    ZStack(alignment: .bottomTrailing) {
                        // Text editor
                        RichTextEditor(attributedText: $attributedText, onTextChange: { newText in
                            // Update the note's content directly with NSAttributedString
                            viewModel.updateNoteContent(note, newContent: newText)
                        }, formattingState: formattingState)
                        .padding(.horizontal, 4)
                        
                        // Also include hidden toolbar for API connections
                        RichTextToolbar(attributedText: $attributedText, textView: textViewHolder.textView, formattingState: formattingState)
                            .frame(width: 0, height: 0)
                            .opacity(0)
                            .accessibilityHidden(true)
                    }
                    
                    // Modern iOS-style toolbar
                    HStack(spacing: 16) {
                        Spacer()
                        
                        // Format menu (typography)
                        FormatMenu(formattingState: formattingState) { action in
                            handleFormatAction(action, for: note)
                        }
                        
                        // Attachment menu (files, images)
                        AttachmentMenu(
                            showImagePicker: $showImagePicker,
                            showDocumentPicker: $showDocumentPicker
                        )
                        
                        // Share button
                        Button(action: {
                            // Handle sharing - would implement share sheet
                            let content = note.title.isEmpty ? attributedText.string : "\(note.title)\n\n\(attributedText.string)"
                            
                            // This would connect to a share sheet in a full implementation
                            print("Would share: \(content)")
                        }) {
                            Image(systemName: "square.and.arrow.up")
                                .font(.system(size: 17, weight: .semibold))
                                .frame(width: 34, height: 34)
                                .background(Color.secondary.opacity(0.1))
                                .clipShape(Circle())
                        }
                    }
                    .padding(.horizontal)
                    .padding(.vertical, 8)
                    .background(
                        Color(UIColor.secondarySystemBackground)
                            .shadow(color: .black.opacity(0.05), radius: 2, x: 0, y: -1)
                    )
                }
                .toolbar {
                    // Keyboard toolbar
                    ToolbarItemGroup(placement: .keyboard) {
                        HStack {
                            // Bold/Italic/Underline quick access in keyboard toolbar
                            Button(action: { handleFormatAction(.bold, for: note) }) {
                                Image(systemName: "bold")
                                    .foregroundColor(formattingState.isBold ? .accentColor : .primary)
                            }
                            
                            Button(action: { handleFormatAction(.italic, for: note) }) {
                                Image(systemName: "italic")
                                    .foregroundColor(formattingState.isItalic ? .accentColor : .primary)
                            }
                            
                            Button(action: { handleFormatAction(.underline, for: note) }) {
                                Image(systemName: "underline")
                                    .foregroundColor(formattingState.isUnderlined ? .accentColor : .primary)
                            }
                            
                            Spacer()
                            
                            Button("Done") {
                                hideKeyboard()
                            }
                            .fontWeight(.semibold)
                        }
                    }
                }
                // Handle various sheet presentations
                .sheet(isPresented: $showImagePicker) {
                    ImagePicker { selectedImage in
                        if let coordinator = textViewHolder.textView?.delegate as? RichTextEditor.Coordinator {
                            coordinator.insertImage(selectedImage)
                        }
                    }
                }
                .sheet(isPresented: $showDocumentPicker) {
                    DocumentPicker { fileURL in
                        if let coordinator = textViewHolder.textView?.delegate as? RichTextEditor.Coordinator {
                            coordinator.insertDocumentLink(url: fileURL, filename: fileURL.lastPathComponent)
                        }
                    }
                }
                .sheet(isPresented: $showColorPicker) {
                    VStack {
                        Text("Text Color")
                            .font(.headline)
                            .padding()
                        
                        ColorPicker("Select Color", selection: $formattingState.textColor)
                            .labelsHidden()
                            .padding()
                        
                        Button("Apply") {
                            handleFormatAction(.textColor, for: note)
                            showColorPicker = false
                        }
                        .buttonStyle(.borderedProminent)
                        .padding()
                    }
                    .presentationDetents([.height(200)])
                }
                // Use id to force full view rebuild when note changes
                .id(noteId)
                .onAppear { [self] in
                    // Load the attributed string directly from the note only if needed
                    let currentText = self.attributedText.string
                    let noteContent = viewModel.attributedContent(for: note)
                    
                    // Only update if content differs to prevent unnecessary redraws
                    if currentText != noteContent.string {
                        self.attributedText = noteContent
                    }
                    
                    // Don't modify text view directly here - let SwiftUI handle it
                    // Just reset formatting state based on the content
                    if self.attributedText.length > 0 {
                        // Apply a conservative check of attributes at position 0
                        let attributes = self.attributedText.attributes(at: 0, effectiveRange: nil)
                        
                        // Reset format state to reflect actual content
                        if let font = attributes[.font] as? UIFont {
                            self.formattingState.isBold = font.fontDescriptor.symbolicTraits.contains(.traitBold)
                            self.formattingState.isItalic = font.fontDescriptor.symbolicTraits.contains(.traitItalic)
                        } else {
                            self.formattingState.isBold = false
                            self.formattingState.isItalic = false
                        }
                        
                        self.formattingState.isUnderlined = attributes[.underlineStyle] != nil
                        
                        if let color = attributes[.foregroundColor] as? UIColor {
                            self.formattingState.textColor = Color(color)
                        } else {
                            self.formattingState.textColor = .primary
                        }
                    } else {
                        // Reset to defaults if empty
                        self.formattingState.isBold = false
                        self.formattingState.isItalic = false
                        self.formattingState.isUnderlined = false
                        self.formattingState.textColor = .primary
                    }
                }
                .onChange(of: selectedNote) { [self] _, _ in
                    // Reset formatting state when switching notes
                    self.formattingState.isBold = false
                    self.formattingState.isItalic = false
                    self.formattingState.isUnderlined = false
                    self.formattingState.textColor = .primary
                    
                    // When selectedNote changes, update content if not nil
                    if let note = selectedNote {
                        self.attributedText = viewModel.attributedContent(for: note)
                    } else {
                        self.attributedText = NSAttributedString(string: "")
                    }
                }
            } else {
                ContentUnavailableView {
                    Label("No Note Selected", systemImage: "square.and.pencil")
                } description: {
                    Text("Select a note from the list or create a new one.")
                }
            }
        }
    }
    
    // Using View extension for keyboard dismissal
    
    /// Handle formatting actions from the format menu
    private func handleFormatAction(_ action: FormatMenu.FormatAction, for note: ScribeNote) {
        // Get the text view and coordinator directly
        guard let textView = textViewHolder.textView,
              let coordinator = textView.delegate as? RichTextEditor.Coordinator else {
            return
        }
        
        // Create a mutable copy of the current text
        let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
        let selectedRange = textView.selectedRange
        
        switch action {
        case .bold:
            self.formattingState.isBold.toggle()
            
            // Handle selection vs insertion point differently
            if selectedRange.length > 0 {
                // Apply to selected text
                mutableAttrText.enumerateAttribute(.font, in: selectedRange) { [self] value, range, _ in
                    let currentFont = value as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
                    var traits = currentFont.fontDescriptor.symbolicTraits
                    
                    if self.formattingState.isBold {
                        traits.insert(.traitBold)
                    } else {
                        traits.remove(.traitBold)
                    }
                    
                    if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                        let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                        mutableAttrText.addAttribute(.font, value: newFont, range: range)
                    }
                }
                
                // Update text view
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                textView.selectedRange = selectedRange
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            } else {
                // Update typing attributes for future text
                var currentAttributes = textView.typingAttributes
                let currentFont = currentAttributes[.font] as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
                var traits = currentFont.fontDescriptor.symbolicTraits
                
                if self.formattingState.isBold {
                    traits.insert(.traitBold)
                } else {
                    traits.remove(.traitBold)
                }
                
                if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                    let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                    currentAttributes[.font] = newFont
                    textView.typingAttributes = currentAttributes
                }
            }
            
        case .italic:
            self.formattingState.isItalic.toggle()
            
            // Similar implementation to bold but for italic
            if selectedRange.length > 0 {
                mutableAttrText.enumerateAttribute(.font, in: selectedRange) { [self] value, range, _ in
                    let currentFont = value as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
                    var traits = currentFont.fontDescriptor.symbolicTraits
                    
                    if self.formattingState.isItalic {
                        traits.insert(.traitItalic)
                    } else {
                        traits.remove(.traitItalic)
                    }
                    
                    if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                        let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                        mutableAttrText.addAttribute(.font, value: newFont, range: range)
                    }
                }
                
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                textView.selectedRange = selectedRange
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            } else {
                var currentAttributes = textView.typingAttributes
                let currentFont = currentAttributes[.font] as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
                var traits = currentFont.fontDescriptor.symbolicTraits
                
                if self.formattingState.isItalic {
                    traits.insert(.traitItalic)
                } else {
                    traits.remove(.traitItalic)
                }
                
                if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                    let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                    currentAttributes[.font] = newFont
                    textView.typingAttributes = currentAttributes
                }
            }
            
        case .underline:
            self.formattingState.isUnderlined.toggle()
            
            if selectedRange.length > 0 {
                if self.formattingState.isUnderlined {
                    mutableAttrText.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: selectedRange)
                } else {
                    mutableAttrText.removeAttribute(.underlineStyle, range: selectedRange)
                }
                
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                textView.selectedRange = selectedRange
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            } else {
                var currentAttributes = textView.typingAttributes
                
                if self.formattingState.isUnderlined {
                    currentAttributes[.underlineStyle] = NSUnderlineStyle.single.rawValue
                } else {
                    currentAttributes.removeValue(forKey: .underlineStyle)
                }
                
                textView.typingAttributes = currentAttributes
            }
            
        case .heading(let style):
            // Determine font size based on heading style
            let fontSize: CGFloat
            switch style {
            case .title: fontSize = 24
            case .headline: fontSize = 18
            default: fontSize = 16
            }
            
            let fontWeight = style == .body ? UIFont.Weight.regular : UIFont.Weight.bold
            let newFont = UIFont.systemFont(ofSize: fontSize, weight: fontWeight)
            
            if selectedRange.length > 0 {
                mutableAttrText.addAttribute(.font, value: newFont, range: selectedRange)
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                textView.selectedRange = selectedRange
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            } else {
                var currentAttributes = textView.typingAttributes
                currentAttributes[.font] = newFont
                textView.typingAttributes = currentAttributes
                
                // Update toolbar state for this font size/style
                self.formattingState.isBold = fontWeight == .bold
            }
            
        case .textColor:
            // Show color picker if not already visible
            if !self.showColorPicker {
                self.showColorPicker = true
            } else {
                // Apply color to selection or typing attributes
                let uiColor = UIColor(self.formattingState.textColor)
                
                if selectedRange.length > 0 {
                    mutableAttrText.addAttribute(.foregroundColor, value: uiColor, range: selectedRange)
                    textView.attributedText = mutableAttrText
                    attributedText = mutableAttrText
                    textView.selectedRange = selectedRange
                    viewModel.updateNoteContent(note, newContent: mutableAttrText)
                } else {
                    var currentAttributes = textView.typingAttributes
                    currentAttributes[.foregroundColor] = uiColor
                    textView.typingAttributes = currentAttributes
                }
            }
            
        case .bulletList:
            // Direct implementation of bullet points function
            if selectedRange.length > 0 {
                // Process selected text paragraphs for bullets
                let fullText = mutableAttrText.string
                let nsString = fullText as NSString
                let paragraphRange = nsString.paragraphRange(for: selectedRange)
                
                // Prepare paragraph style
                let paragraphStyle = NSMutableParagraphStyle()
                paragraphStyle.headIndent = 15
                paragraphStyle.firstLineHeadIndent = 0
                
                // Process paragraphs
                let selectedText = nsString.substring(with: paragraphRange)
                let paragraphs = selectedText.components(separatedBy: "\n")
                var bulletedText = ""
                
                for (index, paragraph) in paragraphs.enumerated() {
                    let trimmedParagraph = paragraph.trimmingCharacters(in: .whitespacesAndNewlines)
                    if !trimmedParagraph.isEmpty {
                        let bulletedParagraph = "• " + paragraph
                        bulletedText += bulletedParagraph
                        if index < paragraphs.count - 1 || selectedText.hasSuffix("\n") {
                            bulletedText += "\n"
                        }
                    } else if index < paragraphs.count - 1 {
                        bulletedText += "\n"
                    }
                }
                
                // Create attributed string with bullets
                let bulletedAttrString = NSMutableAttributedString(string: bulletedText)
                bulletedAttrString.addAttribute(.paragraphStyle, value: paragraphStyle, range: NSRange(location: 0, length: bulletedText.count))
                
                // Replace the original text
                mutableAttrText.replaceCharacters(in: paragraphRange, with: bulletedAttrString)
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                
                // Position cursor at end of bulleted text
                let newPosition = paragraphRange.location + bulletedText.count
                textView.selectedRange = NSRange(location: newPosition, length: 0)
                
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            } else {
                // Insert bullet at cursor position
                let bulletText = "• "
                let bulletAttrString = NSAttributedString(string: bulletText)
                
                mutableAttrText.insert(bulletAttrString, at: selectedRange.location)
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                textView.selectedRange = NSRange(location: selectedRange.location + bulletText.count, length: 0)
                
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            }
            
        case .clearFormatting:
            // Reset formatting state
            self.formattingState.isBold = false
            self.formattingState.isItalic = false
            self.formattingState.isUnderlined = false
            self.formattingState.textColor = .primary
            
            if selectedRange.length > 0 {
                // Clear formatting on selected text
                let plainText = mutableAttrText.string.substring(with: Range(selectedRange, in: mutableAttrText.string)!)
                
                // Default attributes
                let defaultFont = UIFont.preferredFont(forTextStyle: .body)
                let defaultAttributes: [NSAttributedString.Key: Any] = [
                    .font: defaultFont,
                    .foregroundColor: UIColor.label
                ]
                
                let plainAttrString = NSAttributedString(string: plainText, attributes: defaultAttributes)
                mutableAttrText.replaceCharacters(in: selectedRange, with: plainAttrString)
                
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                textView.selectedRange = NSRange(location: selectedRange.location, length: plainText.count)
                
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            } else {
                // Reset typing attributes
                let defaultFont = UIFont.preferredFont(forTextStyle: .body)
                let defaultAttributes: [NSAttributedString.Key: Any] = [
                    .font: defaultFont,
                    .foregroundColor: UIColor.label
                ]
                textView.typingAttributes = defaultAttributes
            }
        }
    }
}

// Observable class to hold the text view reference
class RichTextViewHolder: ObservableObject {
    static let shared = RichTextViewHolder()
    @Published var textView: UITextView?
    
    private init() {}
}

#Preview {
    @MainActor func createPreview() -> some View {
        let container = try! ModelContainer(for: ScribeNote.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))
        let modelContext = container.mainContext
        let viewModel = NoteViewModel(modelContext: modelContext)
        
        // Create an attributed string
        let attributedString = NSAttributedString(string: "This is sample content")
        
        // Create sample note with archived attributed string
        let sampleNote = ScribeNote(title: "Rich Text Sample")
        if let data = try? NSKeyedArchiver.archivedData(withRootObject: attributedString, requiringSecureCoding: true) {
            sampleNote.content = data
        }
        modelContext.insert(sampleNote)
        
        return RichTextNoteEditorView(selectedNote: .constant(sampleNote), viewModel: viewModel)
            .modelContainer(container)
    }
    
    return createPreview()
}


######## Scribe/ViewModel/NoteViewModel.swift ########

import Foundation
import SwiftData
import SwiftUI
import OSLog

/// ViewModel for handling note operations
@Observable @MainActor class NoteViewModel {
    private let logger = Logger(subsystem: "com.rubenreut.Scribe", category: "NoteViewModel")
    private let modelContext: ModelContext
    private var saveTask: Task<Void, Never>? = nil
    
    var selectedNote: ScribeNote?
    var searchText: String = ""
    var notes: [ScribeNote] = []
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
        refreshNotes()
    }
    
    /// Creates a new note and selects it
    func createNewNote() {
        let newNote = ScribeNote()
        
        // Add an empty attributed string with default body styling
        let bodyFont = UIFont.preferredFont(forTextStyle: .body)
        let defaultAttributes: [NSAttributedString.Key: Any] = [
            .font: bodyFont,
            .foregroundColor: UIColor.label
        ]
        let emptyText = NSAttributedString(string: "", attributes: defaultAttributes)
        
        // Save the default styling
        do {
            newNote.content = try NSKeyedArchiver.archivedData(withRootObject: emptyText, requiringSecureCoding: true)
        } catch {
            logger.error("Failed to initialize note with default styling: \(error.localizedDescription)")
        }
        
        modelContext.insert(newNote)
        selectedNote = newNote
        
        // Refresh notes to ensure the new note appears in the list
        refreshNotes()
        
        do {
            try modelContext.save()
        } catch {
            logger.error("Failed to save new note: \(error.localizedDescription)")
        }
        
        // Note created successfully
    }
    
    /// Saves any pending changes to the notes
    func saveChanges() {
        // Cancel any existing save task
        saveTask?.cancel()
        
        // Create a new task with a brief delay to batch rapid changes
        saveTask = Task {
            do {
                try await Task.sleep(for: .milliseconds(Constants.Time.autosaveDelay))
                guard !Task.isCancelled else { return }
                
                try modelContext.save()
                // Changes saved successfully
            } catch {
                logger.error("Failed to save note: \(error.localizedDescription)")
            }
        }
    }
    
    /// Updates a note's title and marks it as modified
    func updateNoteTitle(_ note: ScribeNote, newTitle: String) {
        note.title = newTitle
        note.lastModified = Date()
        saveChanges()
    }
    
    /// Updates a note's content with NSAttributedString and marks it as modified
    func updateNoteContent(_ note: ScribeNote, newContent: NSAttributedString) {
        do {
            // Ensure secure coding for images in NSTextAttachments
            NSAttributedString.registerAttributedStringCoder(for: newContent)
            note.content = try NSKeyedArchiver.archivedData(withRootObject: newContent, requiringSecureCoding: true)
            note.lastModified = Date()
            saveChanges()
        } catch {
            logger.error("Archiving error: \(error.localizedDescription)")
        }
    }
    
    /// Retrieves the attributed content for a note
    func attributedContent(for note: ScribeNote) -> NSAttributedString {
        guard !note.content.isEmpty else {
            return NSAttributedString(string: "")
        }
        
        do {
            // Register necessary classes for secure coding
            NSKeyedUnarchiver.setClass(NSTextAttachment.self, forClassName: "NSTextAttachment")
            NSKeyedUnarchiver.setClass(UIImage.self, forClassName: "UIImage")
            
            let content = try NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(note.content) as? NSAttributedString
            return content ?? NSAttributedString(string: "")
        } catch {
            logger.error("Unarchiving error: \(error.localizedDescription)")
            return NSAttributedString(string: "")
        }
    }
    
    /// Deletes the specified notes
    func deleteNotes(at indexSet: IndexSet) {
        for index in indexSet {
            let noteToDelete = notes[index]
            modelContext.delete(noteToDelete)
            
            // If the deleted note was selected, deselect it
            if selectedNote == noteToDelete {
                selectedNote = nil
            }
        }
        
        // Save changes after deletion
        do {
            try modelContext.save()
        } catch {
            logger.error("Failed to save after deletion: \(error.localizedDescription)")
        }
        
        // Refresh notes to update the UI
        refreshNotes()
        
        // Notes deleted successfully
    }
    
    /// Refreshes the notes array from the model context
    func refreshNotes() {
        do {
            let descriptor = FetchDescriptor<ScribeNote>(sortBy: [SortDescriptor(\.lastModified, order: .reverse)])
            notes = try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch notes: \(error.localizedDescription)")
            notes = []
        }
    }
    
    /// Returns filtered notes based on search text
    var filteredNotes: [ScribeNote] {
        if searchText.isEmpty {
            return notes
        } else {
            return notes.filter { note in
                let content = attributedContent(for: note).string
                return note.title.localizedStandardContains(searchText) ||
                      content.localizedStandardContains(searchText)
            }
        }
    }
    
}

// Extension to ensure NSAttributedString can be properly archived with attachments
extension NSAttributedString {
    static func registerAttributedStringCoder(for attributedString: NSAttributedString) {
        // Register NSTextAttachment for secure coding
        NSKeyedArchiver.setClassName("NSTextAttachment", for: NSTextAttachment.self)
        NSKeyedUnarchiver.setClass(NSTextAttachment.self, forClassName: "NSTextAttachment")
        
        // Register UIImage for secure coding
        NSKeyedArchiver.setClassName("UIImage", for: UIImage.self)
        NSKeyedUnarchiver.setClass(UIImage.self, forClassName: "UIImage")
    }
}
