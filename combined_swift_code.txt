######ScribeUITests.swift###### /Users/rubenreut/Scribe/ScribeUITests/ScribeUITests.swift
//
//  ScribeUITests.swift
//  ScribeUITests
//
//  Created by Ruben Reut on 14/04/2025.
//

import XCTest

final class ScribeUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests itâ€™s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *) {
            // This measures how long it takes to launch your application.
            measure(metrics: [XCTApplicationLaunchMetric()]) {
                XCUIApplication().launch()
            }
        }
    }
}
 # Add an empty line for separation
######ScribeUITestsLaunchTests.swift###### /Users/rubenreut/Scribe/ScribeUITests/ScribeUITestsLaunchTests.swift
//
//  ScribeUITestsLaunchTests.swift
//  ScribeUITests
//
//  Created by Ruben Reut on 14/04/2025.
//

import XCTest

final class ScribeUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
 # Add an empty line for separation
######TestHelpers.swift###### /Users/rubenreut/Scribe/ScribeTests/TestHelpers.swift
import Foundation
import SwiftData
@testable import Scribe

/// Provides test helpers for creating test environments
struct TestHelpers {
    /// Creates an in-memory test container and viewmodel with optional sample data
    /// - Parameter withSampleData: Whether to add sample data to the container
    /// - Returns: A tuple containing the container and viewmodel
    @MainActor
    static func createTestEnvironment(withSampleData: Bool = false) throws -> (container: ModelContainer, viewModel: NoteViewModel) {
        let container = try ModelContainer(
            for: ScribeNote.self,
            configurations: ModelConfiguration(isStoredInMemoryOnly: true)
        )
        
        let viewModel = NoteViewModel(modelContext: container.mainContext)
        
        if withSampleData {
            let note1 = ScribeNote(title: "Shopping", content: "Buy milk")
            let note2 = ScribeNote(title: "Work", content: "Finish project")
            let note3 = ScribeNote(title: "Ideas", content: "New app concept")
            
            container.mainContext.insert(note1)
            container.mainContext.insert(note2)
            container.mainContext.insert(note3)
            
            viewModel.refreshNotes()
        }
        
        return (container, viewModel)
    }
} # Add an empty line for separation
######ScribeTests.swift###### /Users/rubenreut/Scribe/ScribeTests/ScribeTests.swift
//
//  ScribeTests.swift
//  ScribeTests
//
//  Created by Ruben Reut on 14/04/2025.
//

import Testing
import SwiftData
@testable import Scribe

struct ScribeTests {
    @Test func testCreateNote() async throws {
        // Create test environment
        let (_, viewModel) = try TestHelpers.createTestEnvironment()
        
        // Initial note count should be 0
        #expect(viewModel.notes.count == 0, "Should start with no notes")
        
        // Create a new note
        viewModel.createNewNote()
        
        // Verify note was created and selected
        #expect(viewModel.notes.count == 1, "Should have one note after creation")
        #expect(viewModel.selectedNote != nil, "A note should be selected")
        #expect(viewModel.selectedNote?.title == "New Note", "Default title should be set")
        #expect(viewModel.selectedNote?.content == "", "Content should start empty")
    }
    
    @Test func testUpdateNoteContent() async throws {
        // Create test environment
        let (_, viewModel) = try TestHelpers.createTestEnvironment()
        
        // Create a note
        viewModel.createNewNote()
        let note = viewModel.selectedNote!
        
        // Update content
        let newContent = "Test content"
        viewModel.updateNoteContent(note, newContent: newContent)
        
        // Verify content was updated
        #expect(note.content == newContent, "Content should be updated")
    }
    
    @Test func testDeleteNote() async throws {
        // Create test environment
        let (_, viewModel) = try TestHelpers.createTestEnvironment()
        
        // Create a note
        viewModel.createNewNote()
        
        // Verify we have a note
        #expect(viewModel.notes.count == 1, "Should have one note")
        
        // Delete the note
        viewModel.deleteNotes(at: IndexSet(integer: 0))
        
        // Verify note was deleted
        #expect(viewModel.notes.count == 0, "Should have no notes after deletion")
        #expect(viewModel.selectedNote == nil, "No note should be selected after deletion")
    }
    
    @Test func testFilterNotes() async throws {
        // Create test environment with sample data
        let (_, viewModel) = try TestHelpers.createTestEnvironment(withSampleData: true)
        
        // Test with no filter
        #expect(viewModel.filteredNotes.count == 2, "Should show all notes with no filter")
        
        // Test with filter matching title
        viewModel.searchText = "Shopping"
        #expect(viewModel.filteredNotes.count == 1, "Should filter by title")
        #expect(viewModel.filteredNotes.first?.title == "Shopping")
        
        // Test with filter matching content
        viewModel.searchText = "milk"
        #expect(viewModel.filteredNotes.count == 1, "Should filter by content")
        #expect(viewModel.filteredNotes.first?.content == "Buy milk")
        
        // Test with no matches
        viewModel.searchText = "nonexistent"
        #expect(viewModel.filteredNotes.count == 0, "Should return empty array for no matches")
    }
}
 # Add an empty line for separation
######NoteViewModel+AI.swift###### /Users/rubenreut/Scribe/Scribe/ViewModel/NoteViewModel+AI.swift
import Foundation
import SwiftData
import SwiftUI

/// AI-related extensions to the NoteViewModel
extension NoteViewModel {
    // MARK: - Folder Management
    
    /// Available folders
    var folders: [ScribeFolder] {
        get {
            do {
                let descriptor = FetchDescriptor<ScribeFolder>(sortBy: [SortDescriptor(\.name)])
                return try modelContext.fetch(descriptor)
            } catch {
                logger.error("Failed to fetch folders: \(error.localizedDescription)")
                return []
            }
        }
    }
    
    /// Creates a new folder
    /// - Parameters:
    ///   - name: The name for the new folder
    ///   - icon: The system icon name
    ///   - color: The folder color
    /// - Returns: The newly created folder
    func createFolder(name: String, icon: String = "folder", color: UIColor = .systemBlue) -> ScribeFolder {
        let newFolder = ScribeFolder(name: name, icon: icon, color: color)
        modelContext.insert(newFolder)
        saveChanges()
        return newFolder
    }
    
    /// Assigns a note to a folder
    /// - Parameters:
    ///   - note: The note to assign
    ///   - folder: The destination folder
    func assignNote(_ note: ScribeNote, toFolder folder: ScribeFolder) {
        note.folder = folder
        note.lastModified = Date()
        saveChanges()
    }
    
    /// Removes a note from its folder
    /// - Parameter note: The note to remove from folder
    func removeNoteFromFolder(_ note: ScribeNote) {
        note.folder = nil
        note.lastModified = Date()
        saveChanges()
    }
    
    /// Deletes a folder and optionally its notes
    /// - Parameters:
    ///   - folder: The folder to delete
    ///   - deleteNotes: Whether to delete the contained notes as well
    func deleteFolder(_ folder: ScribeFolder, deleteNotes: Bool = false) {
        // Get all notes in the folder
        if let folderNotes = folder.notes {
            // Either delete the notes or just remove them from the folder
            if deleteNotes {
                for note in folderNotes {
                    modelContext.delete(note)
                }
            } else {
                // Just unlink notes from the folder without deleting them
                for note in folderNotes {
                    note.folder = nil
                    note.lastModified = Date()
                }
            }
        }
        
        // Delete the folder itself
        modelContext.delete(folder)
        saveChanges()
        
        // Refresh notes list
        refreshNotes()
        
        print("ðŸ—‘ï¸ Deleted folder: \(folder.name) (with notes: \(deleteNotes))")
    }
    
    /// Gets all notes that belong to a specific folder
    /// - Parameter folder: The folder to get notes for
    /// - Returns: Array of notes in the folder
    func notesInFolder(_ folder: ScribeFolder) -> [ScribeNote] {
        return notes.filter { $0.folder?.persistentModelID == folder.persistentModelID }
    }
    
    // MARK: - AI Organization
    
    /// Organizes notes without folders using AI
    func organizeNotesWithAI() async -> (Bool, String?) {
        // Get API key from secure storage
        guard let apiKey = KeychainHelper.getAPIKey(), !apiKey.isEmpty else {
            logger.error("No API key found for AI organization")
            return (false, "Please set your API key in Settings")
        }
        
        // Get notes without folders
        let notesToOrganize = notes.filter { $0.folder == nil }
        guard !notesToOrganize.isEmpty else {
            logger.info("No notes to organize")
            return (false, "No unorganized notes found")
        }
        
        do {
            print("ðŸ” Organizing \(notesToOrganize.count) notes with AI...")
            let aiService = AIService(apiKey: apiKey)
            
            // Attempt the API call
            let organizations = try await aiService.organizeNotes(notesToOrganize, existingFolders: folders)
            print("âœ… Received organization suggestions: \(organizations.count)")
            
            // Validate we got results
            guard !organizations.isEmpty else {
                return (false, "AI didn't suggest any organization")
            }
            
            // Apply the organizations
            for organization in organizations {
                print("ðŸ“‚ Organizing note: '\(organization.note.title)' â†’ '\(organization.folderName)'")
                if organization.isNewFolder {
                    // Create new folder
                    let newFolder = ScribeFolder(name: organization.folderName)
                    modelContext.insert(newFolder)
                    organization.note.folder = newFolder
                    print("   Created new folder: \(organization.folderName)")
                } else if let existingFolder = folders.first(where: { $0.name == organization.folderName }) {
                    // Use existing folder
                    organization.note.folder = existingFolder
                    print("   Used existing folder: \(organization.folderName)")
                }
                organization.note.lastModified = Date()
            }
            
            // Save changes
            print("ðŸ’¾ Saving changes to model context...")
            try modelContext.save()
            
            // Refresh notes
            print("ðŸ”„ Refreshing notes list...")
            refreshNotes()
            return (true, nil)
        } catch {
            let errorMessage = "AI organization failed: \(error.localizedDescription)"
            logger.error("\(errorMessage)")
            print("âŒ \(errorMessage)")
            return (false, errorMessage)
        }
    }
    
    // MARK: - AI Formatting
    
    /// Formats the content of a note using AI
    /// - Parameter note: The note to format
    /// - Returns: Tuple with success flag and optional error message
    func formatNoteWithAI(_ note: ScribeNote) async -> (Bool, String?) {
        // Get API key from secure storage
        guard let apiKey = KeychainHelper.getAPIKey(), !apiKey.isEmpty else {
            logger.error("No API key found for AI formatting")
            return (false, "Please set your API key in Settings")
        }
        
        // Get current note content
        let currentContent = attributedContent(for: note).string
        guard !currentContent.isEmpty else {
            logger.error("Note content is empty, cannot format")
            return (false, "Note content is empty")
        }
        
        do {
            print("ðŸ” Formatting note with AI: \(note.title)")
            let aiService = AIService(apiKey: apiKey)
            let formattedContent = try await aiService.formatNoteContent(currentContent)
            print("âœ… Received formatting instructions: \(formattedContent.instructions.count)")
            
            // Verify we got formatting instructions
            guard !formattedContent.instructions.isEmpty else {
                return (false, "AI didn't return any formatting")
            }
            
            // Apply the formatting
            print("ðŸ–Œ Applying formatting to note...")
            let formattedAttributedText = applyFormatting(formattedContent)
            updateNoteContent(note, newContent: formattedAttributedText)
            return (true, nil)
        } catch {
            let errorMessage = "AI formatting failed: \(error.localizedDescription)"
            logger.error("\(errorMessage)")
            print("âŒ \(errorMessage)")
            return (false, errorMessage)
        }
    }
    
    /// Applies formatting instructions to create a formatted NSAttributedString
    /// - Parameter formattedContent: The formatting instructions
    /// - Returns: The formatted attributed string
    private func applyFormatting(_ formattedContent: FormattedContent) -> NSAttributedString {
        // Create a new attributed string with formatting
        let mutableAttrText = NSMutableAttributedString()
        
        for instruction in formattedContent.instructions {
            switch instruction {
            case .heading(let text, let level):
                // Add heading with appropriate size and weight
                let fontSize: CGFloat = level == 1 ? 24 : (level == 2 ? 20 : 18)
                let font = UIFont.systemFont(ofSize: fontSize, weight: .bold)
                let attrs: [NSAttributedString.Key: Any] = [
                    .font: font,
                    .foregroundColor: UIColor.label
                ]
                let headingAttr = NSAttributedString(string: text + "\n", attributes: attrs)
                mutableAttrText.append(headingAttr)
                
            case .paragraph(let text):
                // Add paragraph with body font
                let bodyFont = UIFont.preferredFont(forTextStyle: .body)
                let attrs: [NSAttributedString.Key: Any] = [
                    .font: bodyFont,
                    .foregroundColor: UIColor.label
                ]
                let paragraphAttr = NSAttributedString(string: text + "\n\n", attributes: attrs)
                mutableAttrText.append(paragraphAttr)
                
            case .bulletList(let items):
                // Add bullet list
                let bodyFont = UIFont.preferredFont(forTextStyle: .body)
                let paragraphStyle = NSMutableParagraphStyle()
                paragraphStyle.headIndent = 15
                paragraphStyle.firstLineHeadIndent = 0
                paragraphStyle.paragraphSpacing = 4
                
                for item in items {
                    let attrs: [NSAttributedString.Key: Any] = [
                        .font: bodyFont,
                        .foregroundColor: UIColor.label,
                        .paragraphStyle: paragraphStyle
                    ]
                    let bulletItem = "â€¢ " + item + "\n"
                    let bulletAttr = NSAttributedString(string: bulletItem, attributes: attrs)
                    mutableAttrText.append(bulletAttr)
                }
                mutableAttrText.append(NSAttributedString(string: "\n"))
            }
        }
        
        return mutableAttrText
    }
} # Add an empty line for separation
######NoteViewModel.swift###### /Users/rubenreut/Scribe/Scribe/ViewModel/NoteViewModel.swift
import Foundation
import SwiftData
import SwiftUI
import OSLog

/// ViewModel for handling note operations
@Observable @MainActor class NoteViewModel {
    let logger = Logger(subsystem: "com.rubenreut.Scribe", category: "NoteViewModel")
    let modelContext: ModelContext
    private var saveTask: Task<Void, Never>? = nil
    
    var selectedNote: ScribeNote?
    var searchText: String = ""
    var notes: [ScribeNote] = []
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
        refreshNotes()
    }
    
    /// Creates a new note and selects it
    func createNewNote() {
        // Create a local reference to current notes before adding a new one
        let currentNotes = notes
        
        // Create the new note
        let newNote = ScribeNote()
        
        // Add an empty attributed string with default body styling
        let bodyFont = UIFont.preferredFont(forTextStyle: .body)
        let defaultAttributes: [NSAttributedString.Key: Any] = [
            .font: bodyFont,
            .foregroundColor: UIColor.label
        ]
        let emptyText = NSAttributedString(string: "", attributes: defaultAttributes)
        
        // Save the default styling
        do {
            newNote.content = try NSKeyedArchiver.archivedData(withRootObject: emptyText, requiringSecureCoding: true)
        } catch {
            logger.error("Failed to initialize note with default styling: \(error.localizedDescription)")
        }
        
        // Add to model context
        modelContext.insert(newNote)
        
        // Save changes to ensure the note is persisted
        do {
            try modelContext.save()
        } catch {
            logger.error("Failed to save new note: \(error.localizedDescription)")
        }
        
        // Instead of refreshing, manually update the notes array
        // This maintains stability of the list while adding the new note
        notes = [newNote] + currentNotes
        
        // Set the selectedNote after the notes array is updated
        self.selectedNote = newNote
    }
    
    /// Saves any pending changes to the notes
    func saveChanges() {
        // Cancel any existing save task
        saveTask?.cancel()
        
        // Create a new task with a brief delay to batch rapid changes
        saveTask = Task {
            do {
                try await Task.sleep(for: .milliseconds(Constants.Time.autosaveDelay))
                guard !Task.isCancelled else { return }
                
                try modelContext.save()
                // Changes saved successfully
            } catch {
                logger.error("Failed to save note: \(error.localizedDescription)")
            }
        }
    }
    
    /// Updates a note's title and marks it as modified
    func updateNoteTitle(_ note: ScribeNote, newTitle: String) {
        note.title = newTitle
        note.lastModified = Date()
        saveChanges()
    }
    
    /// Updates a note's content with NSAttributedString and marks it as modified
    func updateNoteContent(_ note: ScribeNote, newContent: NSAttributedString) {
        do {
            // Ensure secure coding for images in NSTextAttachments
            NSAttributedString.registerAttributedStringCoder(for: newContent)
            note.content = try NSKeyedArchiver.archivedData(withRootObject: newContent, requiringSecureCoding: true)
            note.lastModified = Date()
            saveChanges()
        } catch {
            logger.error("Archiving error: \(error.localizedDescription)")
        }
    }
    
    /// Retrieves the attributed content for a note
    func attributedContent(for note: ScribeNote) -> NSAttributedString {
        guard !note.content.isEmpty else {
            return NSAttributedString(string: "")
        }
        
        do {
            // Register necessary classes for secure coding
            NSKeyedUnarchiver.setClass(NSTextAttachment.self, forClassName: "NSTextAttachment")
            NSKeyedUnarchiver.setClass(UIImage.self, forClassName: "UIImage")
            
            let content = try NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(note.content) as? NSAttributedString
            return content ?? NSAttributedString(string: "")
        } catch {
            logger.error("Unarchiving error: \(error.localizedDescription)")
            return NSAttributedString(string: "")
        }
    }
    
    /// Deletes the specified notes
    func deleteNotes(at indexSet: IndexSet) {
        // Create a local copy to avoid mutation during the operation
        let notesToDelete = indexSet.map { notes[$0] }
        
        // Check if the selected note will be deleted
        let willDeleteSelected = notesToDelete.contains { note in
            selectedNote == note
        }
        
        // Now delete the notes from the model context
        for note in notesToDelete {
            modelContext.delete(note)
        }
        
        // Save changes after deletion
        do {
            try modelContext.save()
        } catch {
            logger.error("Failed to save after deletion: \(error.localizedDescription)")
        }
        
        // If we're deleting the selected note, deselect it first
        if willDeleteSelected {
            selectedNote = nil
        }
        
        // Finally refresh the notes array
        refreshNotes()
    }
    
    /// Refreshes the notes array from the model context
    func refreshNotes() {
        do {
            let descriptor = FetchDescriptor<ScribeNote>(sortBy: [SortDescriptor(\.lastModified, order: .reverse)])
            notes = try modelContext.fetch(descriptor)
        } catch {
            logger.error("Failed to fetch notes: \(error.localizedDescription)")
            notes = []
        }
    }
    
    /// Returns filtered notes based on search text
    var filteredNotes: [ScribeNote] {
        if searchText.isEmpty {
            return notes
        } else {
            return notes.filter { note in
                let content = attributedContent(for: note).string
                return note.title.localizedStandardContains(searchText) ||
                      content.localizedStandardContains(searchText)
            }
        }
    }
    
}

// Extension to ensure NSAttributedString can be properly archived with attachments
extension NSAttributedString {
    static func registerAttributedStringCoder(for attributedString: NSAttributedString) {
        // Register NSTextAttachment for secure coding
        NSKeyedArchiver.setClassName("NSTextAttachment", for: NSTextAttachment.self)
        NSKeyedUnarchiver.setClass(NSTextAttachment.self, forClassName: "NSTextAttachment")
        
        // Register UIImage for secure coding
        NSKeyedArchiver.setClassName("UIImage", for: UIImage.self)
        NSKeyedUnarchiver.setClass(UIImage.self, forClassName: "UIImage")
    }
}
 # Add an empty line for separation
######Constants.swift###### /Users/rubenreut/Scribe/Scribe/Utilities/Constants.swift
import Foundation

/// Application-wide constants
enum Constants {
    /// Notification names used throughout the app
    enum NotificationNames {
        /// Notification posted when a new note should be created
        static let createNewNote = Notification.Name("CreateNewNote")
    }
    
    /// Time constants
    enum Time {
        /// Autosave delay in milliseconds
        static let autosaveDelay: UInt64 = 500
    }
    
    /// API Constants
    enum API {
        /// OpenAI API endpoint for chat completions
        static let openAIBaseURL = "https://api.openai.com/v1/chat/completions"
        /// Keychain identifier for storing the API key
        static let keychainAPIKeyIdentifier = "ScribeAIServiceAPIKey"
    }
} # Add an empty line for separation
######ViewExtensions.swift###### /Users/rubenreut/Scribe/Scribe/Utilities/ViewExtensions.swift
import SwiftUI
import UIKit

/// Extensions to SwiftUI View for common functionality
extension View {
    /// Hides the keyboard by resigning first responder
    func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
} # Add an empty line for separation
######KeychainHelper.swift###### /Users/rubenreut/Scribe/Scribe/Utilities/KeychainHelper.swift
import Foundation
import Security

class KeychainHelper {
    static func saveAPIKey(_ apiKey: String) -> Bool {
        let data = Data(apiKey.utf8)
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: Constants.API.keychainAPIKeyIdentifier,
            kSecValueData as String: data
        ]
        
        // Delete any existing key before saving
        SecItemDelete(query as CFDictionary)
        
        let status = SecItemAdd(query as CFDictionary, nil)
        return status == errSecSuccess
    }
    
    static func getAPIKey() -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: Constants.API.keychainAPIKeyIdentifier,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var dataTypeRef: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)
        
        if status == errSecSuccess, let data = dataTypeRef as? Data {
            return String(data: data, encoding: .utf8)
        }
        
        return nil
    }
    
    static func deleteAPIKey() -> Bool {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: Constants.API.keychainAPIKeyIdentifier
        ]
        
        let status = SecItemDelete(query as CFDictionary)
        return status == errSecSuccess || status == errSecItemNotFound
    }
}
 # Add an empty line for separation
######Note.swift###### /Users/rubenreut/Scribe/Scribe/Model/Note.swift
import Foundation
import SwiftData
import SwiftUI
import UIKit

/// Represents a folder for organizing notes
@Model
final class ScribeFolder {
    var name: String
    var icon: String
    var colorData: Data
    var createdAt: Date
    
    @Relationship var notes: [ScribeNote]?
    
    init(name: String, icon: String = "folder", color: UIColor = .systemBlue, createdAt: Date = Date()) {
        self.name = name
        self.icon = icon
        self.colorData = try! NSKeyedArchiver.archivedData(withRootObject: color, requiringSecureCoding: true)
        self.createdAt = createdAt
        self.notes = []
    }
    
    var color: UIColor {
        get {
            (try? NSKeyedUnarchiver.unarchivedObject(ofClass: UIColor.self, from: colorData)) ?? .systemBlue
        }
    }
}

/// Represents a note in the Scribe application
@Model
final class ScribeNote {
    var title: String
    var content: Data
    var createdAt: Date
    var lastModified: Date
    
    // Relationship to parent folder (optional)
    var folder: ScribeFolder?
    
    /// Creates a new note with optional parameters
    /// - Parameters:
    ///   - title: The title of the note
    ///   - content: The content as binary data (for attributed string)
    ///   - createdAt: The creation date (defaults to now)
    ///   - lastModified: The last modification date (defaults to now)
    init(title: String = "New Note", content: Data = Data(), createdAt: Date = Date(), lastModified: Date = Date()) {
        self.title = title
        self.content = content
        self.createdAt = createdAt
        self.lastModified = lastModified
    }
}

extension ScribeNote: Equatable {
    static func == (lhs: ScribeNote, rhs: ScribeNote) -> Bool {
        lhs.persistentModelID == rhs.persistentModelID
    }
} # Add an empty line for separation
######FormatProgressView.swift###### /Users/rubenreut/Scribe/Scribe/View/FormatProgressView.swift
import SwiftUI

struct FormatProgressView: View {
    let message: String
    
    var body: some View {
        ZStack {
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 16) {
                ProgressView()
                    .scaleEffect(1.5)
                
                Text(message)
                    .font(.headline)
                    .foregroundColor(.white)
            }
            .padding(24)
            .background(Color(.systemBackground))
            .cornerRadius(12)
            .shadow(radius: 10)
        }
    }
}

struct FormatProgressView_Previews: PreviewProvider {
    static var previews: some View {
        FormatProgressView(message: "Processing...")
    }
}
 # Add an empty line for separation
######RichTextNoteEditorView.swift###### /Users/rubenreut/Scribe/Scribe/View/RichTextNoteEditorView.swift
import SwiftUI
import UIKit
import SwiftData
import OSLog
import UniformTypeIdentifiers

/// View for editing a note with rich text formatting capabilities
struct RichTextNoteEditorView: View {
    @Binding var selectedNote: ScribeNote?
    let viewModel: NoteViewModel
    @State var attributedText = NSAttributedString(string: "")
    @ObservedObject var textViewHolder = RichTextViewHolder.shared
    @StateObject var formattingState = FormattingState()
    @State var isFormatting = false
    @State var errorMessage: String? = nil
    @State var showError = false
    
    // Sheet states for pickers
    @State var showImagePicker = false
    @State var showDocumentPicker = false
    @State private var showColorPicker = false
    
    // Add id to force view refreshes when selected note changes
    private var noteId: String {
        selectedNote?.persistentModelID.storeIdentifier ?? "no-note"
    }
    
    private let logger = Logger(subsystem: "com.rubenreut.Scribe", category: "RichTextNoteEditorView")
    
    var body: some View {
        Group {
            if let note = selectedNote {
                VStack(spacing: 0) {
                    // Title field with iOS-style appearance
                    TextField("Title", text: Binding(
                        get: { note.title },
                        set: { newValue in
                            viewModel.updateNoteTitle(note, newTitle: newValue)
                        }
                    ))
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .padding([.horizontal, .top])
                    .textFieldStyle(.plain)
                    .accessibilityIdentifier("note-title-field")
                    
                    HStack {
                        Text(note.lastModified, style: .date)
                            .font(.caption)
                            .foregroundColor(.secondary)
                        Spacer()
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 4)
                    
                    Divider()
                        .padding(.horizontal)
                    
                    // Rich text editor
                    ZStack(alignment: .bottomTrailing) {
                        // Text editor
                        RichTextEditor(attributedText: $attributedText, onTextChange: { newText in
                            // Update the note's content directly with NSAttributedString
                            viewModel.updateNoteContent(note, newContent: newText)
                        }, formattingState: formattingState)
                        .padding(.horizontal, 4)
                        
                        // Also include hidden toolbar for API connections
                        RichTextToolbar(attributedText: $attributedText, textView: textViewHolder.textView, formattingState: formattingState)
                            .frame(width: 0, height: 0)
                            .opacity(0)
                            .accessibilityHidden(true)
                    }
                    
                    // Modern iOS-style toolbar with AI formatting
                    enhancedToolbar
                }
                .overlay {
                    formattingOverlay
                }
                .toolbar {
                    // Keyboard toolbar
                    ToolbarItemGroup(placement: .keyboard) {
                        HStack {
                            // Bold/Italic/Underline quick access in keyboard toolbar
                            Button(action: { handleFormatAction(.bold, for: note) }) {
                                Image(systemName: "bold")
                                    .foregroundColor(formattingState.isBold ? .accentColor : .primary)
                            }
                            
                            Button(action: { handleFormatAction(.italic, for: note) }) {
                                Image(systemName: "italic")
                                    .foregroundColor(formattingState.isItalic ? .accentColor : .primary)
                            }
                            
                            Button(action: { handleFormatAction(.underline, for: note) }) {
                                Image(systemName: "underline")
                                    .foregroundColor(formattingState.isUnderlined ? .accentColor : .primary)
                            }
                            
                            Spacer()
                            
                            Button("Done") {
                                hideKeyboard()
                            }
                            .fontWeight(.semibold)
                        }
                    }
                }
                // Handle various sheet presentations
                .sheet(isPresented: $showImagePicker) {
                    ImagePicker { selectedImage in
                        if let coordinator = textViewHolder.textView?.delegate as? RichTextEditor.Coordinator {
                            coordinator.insertImage(selectedImage)
                        }
                    }
                }
                .sheet(isPresented: $showDocumentPicker) {
                    DocumentPicker { fileURL in
                        if let coordinator = textViewHolder.textView?.delegate as? RichTextEditor.Coordinator {
                            coordinator.insertDocumentLink(url: fileURL, filename: fileURL.lastPathComponent)
                        }
                    }
                }
                .sheet(isPresented: $showColorPicker) {
                    VStack {
                        Text("Text Color")
                            .font(.headline)
                            .padding()
                        
                        ColorPicker("Select Color", selection: $formattingState.textColor)
                            .labelsHidden()
                            .padding()
                        
                        Button("Apply") {
                            handleFormatAction(.textColor, for: note)
                            showColorPicker = false
                        }
                        .buttonStyle(.borderedProminent)
                        .padding()
                    }
                    .presentationDetents([.height(200)])
                }
                // Use id to force full view rebuild when note changes
                .id(noteId)
                .onAppear { [self] in
                    // Load the attributed string directly from the note only if needed
                    let currentText = self.attributedText.string
                    let noteContent = viewModel.attributedContent(for: note)
                    
                    // Only update if content differs to prevent unnecessary redraws
                    if currentText != noteContent.string {
                        self.attributedText = noteContent
                    }
                    
                    // Don't modify text view directly here - let SwiftUI handle it
                    // Just reset formatting state based on the content
                    if self.attributedText.length > 0 {
                        // Apply a conservative check of attributes at position 0
                        let attributes = self.attributedText.attributes(at: 0, effectiveRange: nil)
                        
                        // Reset format state to reflect actual content
                        if let font = attributes[.font] as? UIFont {
                            self.formattingState.isBold = font.fontDescriptor.symbolicTraits.contains(.traitBold)
                            self.formattingState.isItalic = font.fontDescriptor.symbolicTraits.contains(.traitItalic)
                        } else {
                            self.formattingState.isBold = false
                            self.formattingState.isItalic = false
                        }
                        
                        self.formattingState.isUnderlined = attributes[.underlineStyle] != nil
                        
                        if let color = attributes[.foregroundColor] as? UIColor {
                            self.formattingState.textColor = Color(color)
                        } else {
                            self.formattingState.textColor = .primary
                        }
                    } else {
                        // Reset to defaults if empty
                        self.formattingState.isBold = false
                        self.formattingState.isItalic = false
                        self.formattingState.isUnderlined = false
                        self.formattingState.textColor = .primary
                    }
                }
                .onChange(of: selectedNote) { [self] _, _ in
                    // Reset formatting state when switching notes
                    self.formattingState.isBold = false
                    self.formattingState.isItalic = false
                    self.formattingState.isUnderlined = false
                    self.formattingState.textColor = .primary
                    
                    // When selectedNote changes, update content if not nil
                    if let note = selectedNote {
                        self.attributedText = viewModel.attributedContent(for: note)
                    } else {
                        self.attributedText = NSAttributedString(string: "")
                    }
                }
            } else {
                ContentUnavailableView {
                    Label("No Note Selected", systemImage: "square.and.pencil")
                } description: {
                    Text("Select a note from the list or create a new one.")
                }
            }
        }
    }
    
    // Using View extension for keyboard dismissal
    
    /// Handle formatting actions from the format menu
    func handleFormatAction(_ action: FormatMenu.FormatAction, for note: ScribeNote) {
        // Get the text view and coordinator directly
        guard let textView = textViewHolder.textView,
              let coordinator = textView.delegate as? RichTextEditor.Coordinator else {
            return
        }
        
        // Create a mutable copy of the current text
        let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
        let selectedRange = textView.selectedRange
        
        switch action {
        case .bold:
            self.formattingState.isBold.toggle()
            
            // Handle selection vs insertion point differently
            if selectedRange.length > 0 {
                // Apply to selected text
                mutableAttrText.enumerateAttribute(.font, in: selectedRange) { [self] value, range, _ in
                    let currentFont = value as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
                    var traits = currentFont.fontDescriptor.symbolicTraits
                    
                    if self.formattingState.isBold {
                        traits.insert(.traitBold)
                    } else {
                        traits.remove(.traitBold)
                    }
                    
                    if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                        let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                        mutableAttrText.addAttribute(.font, value: newFont, range: range)
                    }
                }
                
                // Update text view
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                textView.selectedRange = selectedRange
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            } else {
                // Update typing attributes for future text
                var currentAttributes = textView.typingAttributes
                let currentFont = currentAttributes[.font] as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
                var traits = currentFont.fontDescriptor.symbolicTraits
                
                if self.formattingState.isBold {
                    traits.insert(.traitBold)
                } else {
                    traits.remove(.traitBold)
                }
                
                if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                    let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                    currentAttributes[.font] = newFont
                    textView.typingAttributes = currentAttributes
                }
            }
            
        case .italic:
            self.formattingState.isItalic.toggle()
            
            // Similar implementation to bold but for italic
            if selectedRange.length > 0 {
                mutableAttrText.enumerateAttribute(.font, in: selectedRange) { [self] value, range, _ in
                    let currentFont = value as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
                    var traits = currentFont.fontDescriptor.symbolicTraits
                    
                    if self.formattingState.isItalic {
                        traits.insert(.traitItalic)
                    } else {
                        traits.remove(.traitItalic)
                    }
                    
                    if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                        let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                        mutableAttrText.addAttribute(.font, value: newFont, range: range)
                    }
                }
                
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                textView.selectedRange = selectedRange
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            } else {
                var currentAttributes = textView.typingAttributes
                let currentFont = currentAttributes[.font] as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
                var traits = currentFont.fontDescriptor.symbolicTraits
                
                if self.formattingState.isItalic {
                    traits.insert(.traitItalic)
                } else {
                    traits.remove(.traitItalic)
                }
                
                if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                    let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                    currentAttributes[.font] = newFont
                    textView.typingAttributes = currentAttributes
                }
            }
            
        case .underline:
            self.formattingState.isUnderlined.toggle()
            
            if selectedRange.length > 0 {
                if self.formattingState.isUnderlined {
                    mutableAttrText.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: selectedRange)
                } else {
                    mutableAttrText.removeAttribute(.underlineStyle, range: selectedRange)
                }
                
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                textView.selectedRange = selectedRange
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            } else {
                var currentAttributes = textView.typingAttributes
                
                if self.formattingState.isUnderlined {
                    currentAttributes[.underlineStyle] = NSUnderlineStyle.single.rawValue
                } else {
                    currentAttributes.removeValue(forKey: .underlineStyle)
                }
                
                textView.typingAttributes = currentAttributes
            }
            
        case .heading(let style):
            // Determine font size based on heading style
            let fontSize: CGFloat
            switch style {
            case .title: fontSize = 24
            case .headline: fontSize = 18
            default: fontSize = 16
            }
            
            let fontWeight = style == .body ? UIFont.Weight.regular : UIFont.Weight.bold
            let newFont = UIFont.systemFont(ofSize: fontSize, weight: fontWeight)
            
            if selectedRange.length > 0 {
                mutableAttrText.addAttribute(.font, value: newFont, range: selectedRange)
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                textView.selectedRange = selectedRange
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            } else {
                var currentAttributes = textView.typingAttributes
                currentAttributes[.font] = newFont
                textView.typingAttributes = currentAttributes
                
                // Update toolbar state for this font size/style
                self.formattingState.isBold = fontWeight == .bold
            }
            
        case .textColor:
            // Show color picker if not already visible
            if !self.showColorPicker {
                self.showColorPicker = true
            } else {
                // Apply color to selection or typing attributes
                let uiColor = UIColor(self.formattingState.textColor)
                
                if selectedRange.length > 0 {
                    mutableAttrText.addAttribute(.foregroundColor, value: uiColor, range: selectedRange)
                    textView.attributedText = mutableAttrText
                    attributedText = mutableAttrText
                    textView.selectedRange = selectedRange
                    viewModel.updateNoteContent(note, newContent: mutableAttrText)
                } else {
                    var currentAttributes = textView.typingAttributes
                    currentAttributes[.foregroundColor] = uiColor
                    textView.typingAttributes = currentAttributes
                }
            }
            
        case .bulletList:
            // Direct implementation of bullet points function
            if selectedRange.length > 0 {
                // Process selected text paragraphs for bullets
                let fullText = mutableAttrText.string
                let nsString = fullText as NSString
                let paragraphRange = nsString.paragraphRange(for: selectedRange)
                
                // Prepare paragraph style
                let paragraphStyle = NSMutableParagraphStyle()
                paragraphStyle.headIndent = 15
                paragraphStyle.firstLineHeadIndent = 0
                
                // Process paragraphs
                let selectedText = nsString.substring(with: paragraphRange)
                let paragraphs = selectedText.components(separatedBy: "\n")
                var bulletedText = ""
                
                for (index, paragraph) in paragraphs.enumerated() {
                    let trimmedParagraph = paragraph.trimmingCharacters(in: .whitespacesAndNewlines)
                    if !trimmedParagraph.isEmpty {
                        let bulletedParagraph = "â€¢ " + paragraph
                        bulletedText += bulletedParagraph
                        if index < paragraphs.count - 1 || selectedText.hasSuffix("\n") {
                            bulletedText += "\n"
                        }
                    } else if index < paragraphs.count - 1 {
                        bulletedText += "\n"
                    }
                }
                
                // Create attributed string with bullets
                let bulletedAttrString = NSMutableAttributedString(string: bulletedText)
                bulletedAttrString.addAttribute(.paragraphStyle, value: paragraphStyle, range: NSRange(location: 0, length: bulletedText.count))
                
                // Replace the original text
                mutableAttrText.replaceCharacters(in: paragraphRange, with: bulletedAttrString)
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                
                // Position cursor at end of bulleted text
                let newPosition = paragraphRange.location + bulletedText.count
                textView.selectedRange = NSRange(location: newPosition, length: 0)
                
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            } else {
                // Insert bullet at cursor position
                let bulletText = "â€¢ "
                let bulletAttrString = NSAttributedString(string: bulletText)
                
                mutableAttrText.insert(bulletAttrString, at: selectedRange.location)
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                textView.selectedRange = NSRange(location: selectedRange.location + bulletText.count, length: 0)
                
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            }
            
        case .clearFormatting:
            // Reset formatting state
            self.formattingState.isBold = false
            self.formattingState.isItalic = false
            self.formattingState.isUnderlined = false
            self.formattingState.textColor = .primary
            
            if selectedRange.length > 0 {
                // Clear formatting on selected text
                let plainText = mutableAttrText.string.substring(with: Range(selectedRange, in: mutableAttrText.string)!)
                
                // Default attributes
                let defaultFont = UIFont.preferredFont(forTextStyle: .body)
                let defaultAttributes: [NSAttributedString.Key: Any] = [
                    .font: defaultFont,
                    .foregroundColor: UIColor.label
                ]
                
                let plainAttrString = NSAttributedString(string: plainText, attributes: defaultAttributes)
                mutableAttrText.replaceCharacters(in: selectedRange, with: plainAttrString)
                
                textView.attributedText = mutableAttrText
                attributedText = mutableAttrText
                textView.selectedRange = NSRange(location: selectedRange.location, length: plainText.count)
                
                viewModel.updateNoteContent(note, newContent: mutableAttrText)
            } else {
                // Reset typing attributes
                let defaultFont = UIFont.preferredFont(forTextStyle: .body)
                let defaultAttributes: [NSAttributedString.Key: Any] = [
                    .font: defaultFont,
                    .foregroundColor: UIColor.label
                ]
                textView.typingAttributes = defaultAttributes
            }
        }
    }
}

// Observable class to hold the text view reference
class RichTextViewHolder: ObservableObject {
    static let shared = RichTextViewHolder()
    @Published var textView: UITextView?
    
    private init() {}
}

#Preview {
    @MainActor func createPreview() -> some View {
        let container = try! ModelContainer(for: ScribeNote.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))
        let modelContext = container.mainContext
        let viewModel = NoteViewModel(modelContext: modelContext)
        
        // Create an attributed string
        let attributedString = NSAttributedString(string: "This is sample content")
        
        // Create sample note with archived attributed string
        let sampleNote = ScribeNote(title: "Rich Text Sample")
        if let data = try? NSKeyedArchiver.archivedData(withRootObject: attributedString, requiringSecureCoding: true) {
            sampleNote.content = data
        }
        modelContext.insert(sampleNote)
        
        return RichTextNoteEditorView(selectedNote: .constant(sampleNote), viewModel: viewModel)
            .modelContainer(container)
    }
    
    return createPreview()
}
 # Add an empty line for separation
######SettingsView.swift###### /Users/rubenreut/Scribe/Scribe/View/SettingsView.swift
import SwiftUI

struct SettingsView: View {
    @AppStorage("aiProvider") private var aiProvider = "OpenAI"
    @State private var apiKey = ""
    @State private var isSaving = false
    @State private var showAlert = false
    @State private var alertMessage = ""
    @State private var isTesting = false
    @State private var testResponse = ""
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("AI Provider")) {
                    Picker("Provider", selection: $aiProvider) {
                        Text("OpenAI").tag("OpenAI")
                        Text("Claude").tag("Claude")
                    }
                    .pickerStyle(.menu)
                }
                
                Section(header: Text("API Key")) {
                    SecureField("Enter API Key", text: $apiKey)
                    
                    Button(action: saveAPIKey) {
                        if isSaving {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle())
                        } else {
                            Text("Save API Key")
                        }
                    }
                    .disabled(apiKey.isEmpty || isSaving)
                }
                
                Section(header: Text("Testing")) {
                    Button("Test API Connection") {
                        testAPIConnection()
                    }
                    .disabled(apiKey.isEmpty || isTesting || isSaving)
                    
                    if isTesting {
                        ProgressView("Testing connection...")
                            .progressViewStyle(CircularProgressViewStyle())
                    }
                    
                    if !testResponse.isEmpty {
                        Text(testResponse)
                            .font(.caption)
                            .foregroundColor(testResponse.contains("Success") ? .green : .red)
                    }
                }
                
                Section(header: Text("About")) {
                    Text("AI features require an API key from your chosen provider.")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            .navigationTitle("Settings")
            .navigationBarItems(trailing: Button("Done") {
                dismiss()
            })
            .onAppear(perform: loadAPIKey)
            .alert(isPresented: $showAlert) {
                Alert(
                    title: Text("API Key"),
                    message: Text(alertMessage),
                    dismissButton: .default(Text("OK"))
                )
            }
        }
    }
    
    private func testAPIConnection() {
        guard !apiKey.isEmpty else { return }
        
        isTesting = true
        testResponse = ""
        
        Task {
            do {
                let aiService = AIService(apiKey: apiKey, provider: AIService.AIProvider(rawValue: aiProvider) ?? .openAI)
                
                // This tests the simple echo endpoint
                let testPrompt = "Echo this message to verify the API is working: SCRIBE_TEST_SUCCESS"
                let response = try await aiService.testConnection(prompt: testPrompt)
                
                await MainActor.run {
                    isTesting = false
                    if response.contains("SCRIBE_TEST_SUCCESS") {
                        testResponse = "âœ… Success! API connection is working."
                    } else {
                        testResponse = "âš ï¸ API responded, but with unexpected content."
                    }
                }
            } catch let error as AIServiceError {
                await MainActor.run {
                    isTesting = false
                    switch error {
                    case .networkError:
                        testResponse = "âŒ Network error. Check your internet connection."
                    case .apiError(let statusCode, let message):
                        testResponse = "âŒ API error (\(statusCode)): \(message)"
                    case .invalidResponseFormat:
                        testResponse = "âŒ Invalid response from API."
                    case .missingAPIKey:
                        testResponse = "âŒ API key is missing."
                    }
                }
            } catch {
                await MainActor.run {
                    isTesting = false
                    testResponse = "âŒ Error: \(error.localizedDescription)"
                }
            }
        }
    }
    
    private func loadAPIKey() {
        apiKey = KeychainHelper.getAPIKey() ?? ""
    }
    
    private func saveAPIKey() {
        isSaving = true
        
        Task {
            let success = KeychainHelper.saveAPIKey(apiKey)
            
            await MainActor.run {
                isSaving = false
                showAlert = true
                alertMessage = success ? "API key saved successfully" : "Failed to save API key"
            }
        }
    }
}

struct SettingsView_Previews: PreviewProvider {
    static var previews: some View {
        SettingsView()
    }
}
 # Add an empty line for separation
######RichTextNoteEditorView+AI.swift###### /Users/rubenreut/Scribe/Scribe/View/RichTextNoteEditorView+AI.swift
import SwiftUI

/// AI formatting extension for RichTextNoteEditorView
extension RichTextNoteEditorView {
    /// AI formatting button for the toolbar
    var formatWithAIButton: some View {
        Button {
            if let note = selectedNote {
                formatWithAI(note: note)
            }
        } label: {
            Image(systemName: "wand.and.stars")
                .font(.system(size: 17, weight: .semibold))
                .frame(width: 34, height: 34)
                .background(Color.secondary.opacity(0.1))
                .clipShape(Circle())
        }
        .disabled(isFormatting || selectedNote == nil)
    }
    
    // Error handling is done in the main view
    
    /// Apply AI formatting to the current note
    func formatWithAI(note: ScribeNote) {
        guard !isFormatting else { return }
        
        isFormatting = true
        errorMessage = nil
        
        // Get current note content
        let currentContent = attributedText.string
        
        Task {
            let (success, error) = await viewModel.formatNoteWithAI(note)
            
            // Update UI on the main thread
            await MainActor.run {
                isFormatting = false
                
                if success {
                    // If successful, update the view with the new content
                    attributedText = viewModel.attributedContent(for: note)
                } else if let errorMsg = error {
                    // Show error message
                    errorMessage = errorMsg
                    showError = true
                }
            }
        }
    }
    
    /// Enhanced toolbar with AI formatting button
    var enhancedToolbar: some View {
        HStack(spacing: 16) {
            Spacer()
            
            // Format menu (typography)
            FormatMenu(formattingState: formattingState) { action in
                if let note = selectedNote {
                    handleFormatAction(action, for: note)
                }
            }
            
            // AI formatting button
            formatWithAIButton
            
            // Attachment menu (files, images)
            AttachmentMenu(
                showImagePicker: $showImagePicker,
                showDocumentPicker: $showDocumentPicker
            )
            
            // Share button
            Button(action: {
                if let note = selectedNote {
                    let content = note.title.isEmpty ? attributedText.string : "\(note.title)\n\n\(attributedText.string)"
                    print("Would share: \(content)")
                }
            }) {
                Image(systemName: "square.and.arrow.up")
                    .font(.system(size: 17, weight: .semibold))
                    .frame(width: 34, height: 34)
                    .background(Color.secondary.opacity(0.1))
                    .clipShape(Circle())
            }
        }
        .padding(.horizontal)
        .padding(.vertical, 8)
        .background(
            Color(UIColor.secondarySystemBackground)
                .shadow(color: .black.opacity(0.05), radius: 2, x: 0, y: -1)
        )
    }
    
    /// Formatting progress overlay
    var formattingOverlay: some View {
        Group {
            if isFormatting {
                FormatProgressView(message: "Formatting note...")
            }
        }
        .alert("Formatting Error", isPresented: $showError, presenting: errorMessage) { _ in
            Button("OK") { showError = false }
        } message: { error in
            Text(error)
        }
    }
} # Add an empty line for separation
######NoteEditorView.swift###### /Users/rubenreut/Scribe/Scribe/View/NoteEditorView.swift
import SwiftUI
import SwiftData
import OSLog
// Import view extensions
import UIKit

/// View for editing a single note
struct NoteEditorView: View {
    @Binding var note: ScribeNote?
    let viewModel: NoteViewModel
    private let logger = Logger(subsystem: "com.rubenreut.Scribe", category: "NoteEditorView")
    
    @Environment(\.undoManager) private var undoManager
    
    var body: some View {
        Group {
            if let note = note {
                VStack(spacing: 0) {
                    TextField("Title", text: Binding(
                        get: { note.title },
                        set: { newValue in
                            viewModel.updateNoteTitle(note, newTitle: newValue)
                        }
                    ))
                    .font(.largeTitle)
                    .padding([.horizontal, .top])
                    .textFieldStyle(.plain)
                    .accessibilityIdentifier("note-title-field")
                    
                    Divider()
                        .padding(.horizontal)
                    
                    TextEditor(text: Binding(
                        get: { 
                            // Get plain text from the attributed string
                            return viewModel.attributedContent(for: note).string
                        },
                        set: { newValue in
                            // Create a simple attributed string from plain text
                            let attributedString = NSAttributedString(string: newValue)
                            viewModel.updateNoteContent(note, newContent: attributedString)
                        }
                    ))
                    .font(.body)
                    .scrollContentBackground(.hidden)
                    .background(Color(.systemBackground))
                    .padding()
                    .accessibilityIdentifier("note-content-field")
                    
                    HStack {
                        Spacer()
                        Text("Last edited: \(note.lastModified, style: .relative)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .padding(.horizontal)
                            .accessibilityLabel("Last edited \(note.lastModified.formatted())")
                    }
                    .padding(.bottom, 4)
                }
                .toolbar {
                    ToolbarItemGroup(placement: .keyboard) {
                        Spacer()
                        
                        Button("Done") {
                            hideKeyboard()
                        }
                        .accessibilityIdentifier("keyboard-done-button")
                    }
                    
                    ToolbarItemGroup(placement: .primaryAction) {
                        if let undoManager = undoManager {
                            Button {
                                undoManager.undo()
                            } label: {
                                Label("Undo", systemImage: "arrow.uturn.backward")
                            }
                            .disabled(!undoManager.canUndo)
                            
                            Button {
                                undoManager.redo()
                            } label: {
                                Label("Redo", systemImage: "arrow.uturn.forward")
                            }
                            .disabled(!undoManager.canRedo)
                        }
                    }
                }
            } else {
                ContentUnavailableView(
                    label: {
                        Label("No Note Selected", systemImage: "square.and.pencil")
                    },
                    description: {
                        Text("Select a note from the list or create a new one.")
                    }
                )
            }
        }
        .task(id: note?.persistentModelID) {
            // No need to log routine view appearance
        }
    }
    
    // Using View extension for keyboard dismissal
}

#Preview {
    @MainActor func createPreview() -> some View {
        let container = try! ModelContainer(for: ScribeNote.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))
        let modelContext = container.mainContext
        let viewModel = NoteViewModel(modelContext: modelContext)
        
        // Create an attributed string
        let attributedString = NSAttributedString(string: "This is sample content")
        
        // Create sample note with archived attributed string
        let sampleNote = ScribeNote(title: "Sample Note")
        if let data = try? NSKeyedArchiver.archivedData(withRootObject: attributedString, requiringSecureCoding: true) {
            sampleNote.content = data
        }
        modelContext.insert(sampleNote)
        
        return NoteEditorView(note: .constant(sampleNote), viewModel: viewModel)
            .modelContainer(container)
    }
    
    return createPreview()
}
 # Add an empty line for separation
######DocumentPicker.swift###### /Users/rubenreut/Scribe/Scribe/View/DocumentPicker.swift
import SwiftUI
import UniformTypeIdentifiers
import UIKit

struct DocumentPicker: UIViewControllerRepresentable {
    @Environment(\.presentationMode) var presentationMode
    var completion: (URL) -> Void
    
    func makeUIViewController(context: Context) -> UIDocumentPickerViewController {
        // Allow all document types
        let supportedTypes: [UTType] = [.pdf, .plainText, .image, .audio, .movie, .spreadsheet, .presentation]
        let picker = UIDocumentPickerViewController(forOpeningContentTypes: supportedTypes)
        picker.allowsMultipleSelection = false
        picker.delegate = context.coordinator
        return picker
    }
    
    func updateUIViewController(_ uiViewController: UIDocumentPickerViewController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UIDocumentPickerDelegate {
        let parent: DocumentPicker
        
        init(_ parent: DocumentPicker) {
            self.parent = parent
        }
        
        func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
            guard let url = urls.first else { return }
            
            // Start accessing the security-scoped resource
            let gotAccess = url.startAccessingSecurityScopedResource()
            
            if gotAccess {
                parent.completion(url)
                // Make sure you release the security-scoped resource when finished
                DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                    url.stopAccessingSecurityScopedResource()
                }
            }
            
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
} # Add an empty line for separation
######RichTextEditor.swift###### /Users/rubenreut/Scribe/Scribe/View/RichTextEditor.swift
import SwiftUI
import UIKit

/// A formatting state class to hold the current styling state
class FormattingState: ObservableObject {
    @Published var isBold: Bool = false
    @Published var isItalic: Bool = false
    @Published var isUnderlined: Bool = false
    @Published var textColor: Color = .primary
}

/// A SwiftUI wrapper around UITextView for rich text editing
struct RichTextEditor: UIViewRepresentable {
    @Binding var attributedText: NSAttributedString
    var onTextChange: (NSAttributedString) -> Void
    
    // Formatting state (shared with toolbar)
    @ObservedObject var formattingState: FormattingState
    
    // Configuration options
    var backgroundColor: UIColor = .systemBackground
    var tintColor: UIColor = .label
    
    func makeUIView(context: Context) -> UITextView {
        let textView = UITextView()
        textView.delegate = context.coordinator
        textView.backgroundColor = backgroundColor
        textView.tintColor = tintColor
        
        // Use body text as default styling
        let bodyFont = UIFont.preferredFont(forTextStyle: .body)
        textView.font = bodyFont
        
        // Set default typing attributes for consistent formatting
        textView.typingAttributes = [
            .font: bodyFont,
            .foregroundColor: UIColor.label
        ]
        
        // Configure text view behavior
        textView.isScrollEnabled = true
        textView.isEditable = true
        textView.isUserInteractionEnabled = true
        textView.autocapitalizationType = .sentences
        textView.autocorrectionType = .default
        textView.allowsEditingTextAttributes = true
        textView.dataDetectorTypes = [.link]
        textView.isSelectable = true
        
        // Improve performance by setting these properties
        textView.layoutManager.allowsNonContiguousLayout = false
        textView.textContainerInset = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)
        
        // Ensure content text is applied before setting references
        if attributedText.length > 0 {
            textView.attributedText = attributedText
        } else {
            // If there's no text, create an empty attributed string with body formatting
            textView.attributedText = NSAttributedString(
                string: "",
                attributes: [.font: bodyFont, .foregroundColor: UIColor.label]
            )
        }
        
        // Important: Set this in the coordinator
        context.coordinator.textView = textView
        
        // Store reference in the shared holder immediately
        DispatchQueue.main.async {
            RichTextViewHolder.shared.textView = textView
        }
        
        return textView
    }
    
    func updateUIView(_ textView: UITextView, context: Context) {
        // Only update if the text has actually changed to prevent unnecessary refreshes
        let textViewString = textView.attributedText.string
        let newString = attributedText.string
        
        if textViewString != newString || textView.attributedText.length != attributedText.length {
            // Save cursor position and selection state
            let selectedRange = textView.selectedRange
            let isFirstResponder = textView.isFirstResponder
            
            // Disable delegate temporarily to prevent unwanted calls
            let oldDelegate = textView.delegate
            textView.delegate = nil
            
            // Update the text
            textView.attributedText = attributedText
            
            // Re-enable delegate
            textView.delegate = oldDelegate
            
            // Restore cursor position with thorough bounds checking
            if NSLocationInRange(selectedRange.location, NSRange(location: 0, length: attributedText.length)) {
                textView.selectedRange = selectedRange
            } else if attributedText.length > 0 {
                // If cursor was outside valid range, place at end of text
                textView.selectedRange = NSRange(location: min(selectedRange.location, attributedText.length), length: 0)
            } else {
                textView.selectedRange = NSRange(location: 0, length: 0)
            }
            
            // Make sure first responder state is preserved
            if isFirstResponder && !textView.isFirstResponder {
                textView.becomeFirstResponder()
            }
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UITextViewDelegate {
        var parent: RichTextEditor
        var textView: UITextView?
        
        init(_ parent: RichTextEditor) {
            self.parent = parent
        }
        
        func textViewDidChange(_ textView: UITextView) {
            self.textView = textView
            
            // Create non-mutable copy of the text to avoid reference issues
            let textCopy = NSAttributedString(attributedString: textView.attributedText)
            
            // Optimize for large content changes
            let shouldDelayUpdate = textView.text.count > 1000
                                
            // For smaller content, update immediately
            if !shouldDelayUpdate {
                self.parent.attributedText = textCopy
                self.parent.onTextChange(textCopy)
            } else {
                // For larger content, batch updates with slight delay to prevent lag
                DispatchQueue.main.async { [weak self] in
                    guard let self = self else { return }
                    self.parent.attributedText = textCopy
                    self.parent.onTextChange(textCopy)
                }
            }
        }
        
        // Add this to ensure styling is preserved when view appears/reappears
        func textViewDidEndEditing(_ textView: UITextView) {
            // Save the final attributed text when editing ends
            let textCopy = NSAttributedString(attributedString: textView.attributedText)
            self.parent.attributedText = textCopy
            self.parent.onTextChange(textCopy)
        }
        
        // Method to insert images into the rich text
        func insertImage(_ image: UIImage) {
            guard let textView = self.textView else { return }
            
            // Create the NSTextAttachment
            let attachment = NSTextAttachment()
            attachment.image = image
            
            // Adjust attachment bounds (resize if necessary)
            let maxWidth = textView.frame.size.width - 20
            let imageRatio = image.size.height / image.size.width
            let attachmentWidth = min(maxWidth, image.size.width)
            let attachmentHeight = attachmentWidth * imageRatio
            attachment.bounds = CGRect(x: 0, y: 0, width: attachmentWidth, height: attachmentHeight)

            // Create attributed string from attachment
            let attrStringWithImage = NSAttributedString(attachment: attachment)

            // Insert at the current cursor location
            let mutableAttrString = NSMutableAttributedString(attributedString: textView.attributedText)
            let selectedRange = textView.selectedRange
            mutableAttrString.insert(attrStringWithImage, at: selectedRange.location)

            // Update textView
            textView.attributedText = mutableAttrString
            
            // Move cursor after the inserted image
            textView.selectedRange = NSRange(location: selectedRange.location + 1, length: 0)
            
            // Notify parent SwiftUI view about changes
            parent.attributedText = textView.attributedText
            parent.onTextChange(textView.attributedText)
        }
        
        // Method to insert a document reference/link
        func insertDocumentLink(url: URL, filename: String) {
            guard let textView = self.textView else { return }
            
            // Create a link text with the file name
            let linkText = " ðŸ“Ž \(filename) "
            
            // Create an attributed string with a link
            let linkAttributes: [NSAttributedString.Key: Any] = [
                .link: url,
                .foregroundColor: UIColor.systemBlue,
                .underlineStyle: NSUnderlineStyle.single.rawValue,
                .backgroundColor: UIColor.systemGray6
            ]
            
            let linkString = NSAttributedString(string: linkText, attributes: linkAttributes)
            
            // Insert at the current cursor location
            let mutableAttrString = NSMutableAttributedString(attributedString: textView.attributedText)
            let selectedRange = textView.selectedRange
            mutableAttrString.insert(linkString, at: selectedRange.location)
            
            // Update textView
            textView.attributedText = mutableAttrString
            
            // Move cursor after the inserted link
            textView.selectedRange = NSRange(location: selectedRange.location + linkText.count, length: 0)
            
            // Notify parent SwiftUI view about changes
            parent.attributedText = textView.attributedText
            parent.onTextChange(textView.attributedText)
        }
        
        // Update toolbar state based on cursor position
        func textViewDidChangeSelection(_ textView: UITextView) {
            self.textView = textView
            
            // Throttle updates to formatting state to prevent lag
            // Only update if selection is stable
            let currentSelection = textView.selectedRange
            let shouldUpdateFormatting = currentSelection.location != 0 || currentSelection.length > 0
            
            // Update the shared text view holder outside the main state update
            // to prevent performance issues
            RichTextViewHolder.shared.textView = textView
            
            // Don't update formatting state if text is empty
            if textView.text.isEmpty {
                self.resetFormattingState()
                return
            }
            
            // We only want to update if we have a valid position that makes sense to check
            if shouldUpdateFormatting {
                DispatchQueue.main.async { [weak self] in
                    guard let self = self, 
                          let textView = self.textView,
                          textView.selectedRange == currentSelection else { return }
                    
                    self.updateFormattingState(for: textView)
                }
            }
        }
        
        // Helper to update formatting state without duplicating code
        private func updateFormattingState(for textView: UITextView) {
            let cursorPosition = textView.selectedRange.location
            let selectionLength = textView.selectedRange.length
            
            // If we have a selection, check the attributes of the first character
            if selectionLength > 0 && textView.attributedText.length > cursorPosition {
                self.updateFormattingFromAttributes(
                    textView.textStorage.attributes(at: cursorPosition, effectiveRange: nil)
                )
            }
            // If we have just a cursor and it's not at the start, check character to the left
            else if selectionLength == 0 && cursorPosition > 0 && textView.attributedText.length >= cursorPosition {
                self.updateFormattingFromAttributes(
                    textView.textStorage.attributes(at: cursorPosition - 1, effectiveRange: nil)
                )
            }
            // If at beginning of text, check typing attributes for future input
            else {
                self.updateFormattingFromAttributes(textView.typingAttributes)
            }
        }
        
        // Helper to update the format state from attributes dictionary
        private func updateFormattingFromAttributes(_ attributes: [NSAttributedString.Key: Any]) {
            // Check for font traits
            if let font = attributes[.font] as? UIFont {
                self.parent.formattingState.isBold = font.fontDescriptor.symbolicTraits.contains(.traitBold)
                self.parent.formattingState.isItalic = font.fontDescriptor.symbolicTraits.contains(.traitItalic)
            } else {
                // Default state if no font
                self.parent.formattingState.isBold = false
                self.parent.formattingState.isItalic = false
            }
            
            // Check for underline
            self.parent.formattingState.isUnderlined = attributes[.underlineStyle] != nil
            
            // Update text color if present
            if let color = attributes[.foregroundColor] as? UIColor {
                self.parent.formattingState.textColor = Color(color)
            } else {
                self.parent.formattingState.textColor = .primary
            }
        }
        
        // Reset formatting state to defaults
        private func resetFormattingState() {
            self.parent.formattingState.isBold = false
            self.parent.formattingState.isItalic = false
            self.parent.formattingState.isUnderlined = false
            self.parent.formattingState.textColor = .primary
        }
    }
}

/// A toolbar for rich text editing actions
struct RichTextToolbar: View {
    // Singleton instance for external access
    static var shared: RichTextToolbar?
    
    @Binding var attributedText: NSAttributedString
    let textView: UITextView?  // Reference to the active UITextView
    
    // Shared formatting state
    @ObservedObject var formattingState: FormattingState
    
    init(attributedText: Binding<NSAttributedString>, textView: UITextView?, formattingState: FormattingState) {
        self._attributedText = attributedText
        self.textView = textView
        self.formattingState = formattingState
        
        // Set shared instance
        Self.shared = self
    }
    
    var body: some View {
        // We're not displaying the traditional toolbar in the new UI design
        // But we need to keep the toolbar structure for the formatting methods
        Color.clear.frame(width: 0, height: 0)
            .accessibilityHidden(true)
            .id(1000) // Add a tag that can be found for direct method access
            .sheet(isPresented: $showColorPickerVisible) {
                ColorPicker("Text Color", selection: $formattingState.textColor)
                    .padding()
                    .onChange(of: formattingState.textColor) { [self] _ in
                        self.applyTextColor()
                    }
                    .presentationDetents([.height(200)])
            }
    }
    
    // State for color picker sheet
    @State private var showColorPickerVisible = false
    
    // Apply bold formatting
    func toggleBold() {
        formattingState.isBold.toggle()
        
        guard let textView = textView else { return }

        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            // Scenario: User has selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            
            // Store the original selection to restore it later
            let originalSelection = textView.selectedRange
            
            // Using a more efficient approach with fewer iterations
            let fullRange = NSRange(location: 0, length: mutableAttrText.length)
            mutableAttrText.enumerateAttribute(.font, in: selectedRange, options: []) { value, range, _ in
                let currentFont = value as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
                var traits = currentFont.fontDescriptor.symbolicTraits
                
                // Update traits based on formatting state
                if formattingState.isBold {
                    traits.insert(.traitBold)
                } else {
                    traits.remove(.traitBold)
                }
                
                // Create new font with updated traits
                if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                    let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                    
                    // Collect other existing attributes at this range to preserve them
                    var combinedAttributes: [NSAttributedString.Key: Any] = [.font: newFont]
                    
                    // Add other existing attributes
                    mutableAttrText.attributes(at: range.location, effectiveRange: nil).forEach { key, value in
                        if key != .font {
                            combinedAttributes[key] = value
                        }
                    }
                    
                    // Apply all attributes at once
                    mutableAttrText.addAttributes(combinedAttributes, range: range)
                }
            }
            
            // Update the text and restore selection
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            
            // Ensure selection is within bounds
            if NSLocationInRange(originalSelection.location, NSRange(location: 0, length: mutableAttrText.length)) {
                textView.selectedRange = originalSelection
            } else {
                textView.selectedRange = NSRange(location: mutableAttrText.length, length: 0)
            }
        } else {
            // Scenario: No selection; set typing attributes for future input
            var currentAttributes = textView.typingAttributes
            let currentFont = currentAttributes[.font] as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
            var traits = currentFont.fontDescriptor.symbolicTraits

            if formattingState.isBold {
                traits.insert(.traitBold)
            } else {
                traits.remove(.traitBold)
            }

            if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                currentAttributes[.font] = newFont
                textView.typingAttributes = currentAttributes
            }
        }
    }
    
    // Apply italic formatting
    func toggleItalic() {
        formattingState.isItalic.toggle()
        
        guard let textView = textView else { return }

        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            // Scenario: User has selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            
            mutableAttrText.enumerateAttribute(.font, in: selectedRange) { value, range, _ in
                let currentFont = value as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
                var traits = currentFont.fontDescriptor.symbolicTraits
                
                if formattingState.isItalic {
                    traits.insert(.traitItalic)
                } else {
                    traits.remove(.traitItalic)
                }
                
                if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                    let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                    mutableAttrText.addAttribute(.font, value: newFont, range: range)
                }
            }
            
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            textView.selectedRange = selectedRange
        } else {
            // Scenario: No selection; set typing attributes for future input
            var currentAttributes = textView.typingAttributes
            let currentFont = currentAttributes[.font] as? UIFont ?? UIFont.preferredFont(forTextStyle: .body)
            var traits = currentFont.fontDescriptor.symbolicTraits

            if formattingState.isItalic {
                traits.insert(.traitItalic)
            } else {
                traits.remove(.traitItalic)
            }

            if let descriptor = currentFont.fontDescriptor.withSymbolicTraits(traits) {
                let newFont = UIFont(descriptor: descriptor, size: currentFont.pointSize)
                currentAttributes[.font] = newFont
                textView.typingAttributes = currentAttributes
            }
        }
    }
    
    // Apply underline formatting
    func toggleUnderline() {
        formattingState.isUnderlined.toggle()
        
        guard let textView = textView else { return }
        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            // Scenario: User has selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            
            if formattingState.isUnderlined {
                mutableAttrText.addAttribute(.underlineStyle, value: NSUnderlineStyle.single.rawValue, range: selectedRange)
            } else {
                mutableAttrText.removeAttribute(.underlineStyle, range: selectedRange)
            }
            
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            textView.selectedRange = selectedRange
        } else {
            // Scenario: No selection; set typing attributes for future input
            var currentAttributes = textView.typingAttributes
            
            if formattingState.isUnderlined {
                currentAttributes[.underlineStyle] = NSUnderlineStyle.single.rawValue
            } else {
                currentAttributes.removeValue(forKey: .underlineStyle)
            }
            
            textView.typingAttributes = currentAttributes
        }
    }
    
    // Apply text color
    func applyTextColor() {
        guard let textView = textView else { return }
        let selectedRange = textView.selectedRange
        let uiColor = UIColor(formattingState.textColor)
        
        if selectedRange.length > 0 {
            // Scenario: User has selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            
            // More efficient to add all attributes at once if possible
            var attributes: [NSAttributedString.Key: Any] = [.foregroundColor: uiColor]
            
            // Include font attributes if they exist at this position
            if let existingFont = mutableAttrText.attribute(.font, at: selectedRange.location, effectiveRange: nil) as? UIFont {
                attributes[.font] = existingFont
            }
            
            mutableAttrText.addAttributes(attributes, range: selectedRange)
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            textView.selectedRange = selectedRange
        } else {
            // Scenario: No selection; set typing attributes for future input
            var currentAttributes = textView.typingAttributes
            currentAttributes[.foregroundColor] = uiColor
            textView.typingAttributes = currentAttributes
        }
    }
    
    // Apply heading format
    func applyHeading(_ style: Font.TextStyle) {
        guard let textView = textView else { return }
        let selectedRange = textView.selectedRange
        
        // Determine font size based on heading style
        let fontSize: CGFloat
        switch style {
        case .title: fontSize = 24
        case .headline: fontSize = 18
        default: fontSize = 16
        }
        
        let fontWeight = style == .body ? UIFont.Weight.regular : UIFont.Weight.bold
        let newFont = UIFont.systemFont(ofSize: fontSize, weight: fontWeight)
        
        if selectedRange.length > 0 {
            // Scenario: User has selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            
            // Preserve bold/italic traits if present
            mutableAttrText.enumerateAttribute(.font, in: selectedRange) { value, range, _ in
                if let currentFont = value as? UIFont {
                    var traits = currentFont.fontDescriptor.symbolicTraits
                    if let descriptor = newFont.fontDescriptor.withSymbolicTraits(traits) {
                        let styledFont = UIFont(descriptor: descriptor, size: fontSize)
                        mutableAttrText.addAttribute(.font, value: styledFont, range: range)
                    } else {
                        mutableAttrText.addAttribute(.font, value: newFont, range: range)
                    }
                } else {
                    mutableAttrText.addAttribute(.font, value: newFont, range: range)
                }
            }
            
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            textView.selectedRange = selectedRange
        } else {
            // Scenario: No selection; set typing attributes for future input
            var currentAttributes = textView.typingAttributes
            currentAttributes[.font] = newFont
            textView.typingAttributes = currentAttributes
            
            // Update toolbar state for this font size/style
            formattingState.isBold = fontWeight == .bold
        }
    }
    
    // Apply bullet points more efficiently using paragraph style
    func applyBulletPoints() {
        guard let textView = textView else { return }
        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            // Processing selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            let fullText = mutableAttrText.string
            
            // Get the paragraph ranges from the selection
            let nsString = fullText as NSString
            let paragraphRange = nsString.paragraphRange(for: selectedRange)
            
            // Create paragraph style with indentation
            let paragraphStyle = NSMutableParagraphStyle()
            paragraphStyle.headIndent = 15
            paragraphStyle.firstLineHeadIndent = 0
            paragraphStyle.paragraphSpacing = 4
            
            // Split the selected text into paragraphs and process each one
            let selectedText = nsString.substring(with: paragraphRange)
            let paragraphs = selectedText.components(separatedBy: "\n")
            var bulletedText = ""
            
            for (index, paragraph) in paragraphs.enumerated() {
                let trimmedParagraph = paragraph.trimmingCharacters(in: .whitespacesAndNewlines)
                if !trimmedParagraph.isEmpty {
                    let bulletedParagraph = "â€¢ " + paragraph
                    bulletedText += bulletedParagraph
                    if index < paragraphs.count - 1 || selectedText.hasSuffix("\n") {
                        bulletedText += "\n"
                    }
                } else if index < paragraphs.count - 1 {
                    bulletedText += "\n"
                }
            }
            
            // Apply the formatted text with attributes while preserving existing attributes
            let bulletedAttrString = NSMutableAttributedString(string: bulletedText)
            
            // Apply paragraph style to the entire text
            bulletedAttrString.addAttribute(.paragraphStyle, value: paragraphStyle, range: NSRange(location: 0, length: bulletedText.count))
            
            // Copy other attributes from original text
            let originalAttrs = mutableAttrText.attributes(at: paragraphRange.location, effectiveRange: nil)
            for (key, value) in originalAttrs {
                if key != .paragraphStyle {
                    bulletedAttrString.addAttribute(key, value: value, range: NSRange(location: 0, length: bulletedText.count))
                }
            }
            
            mutableAttrText.replaceCharacters(in: paragraphRange, with: bulletedAttrString)
            
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            
            // Set cursor position at the end of the modified text
            let newCursorPosition = paragraphRange.location + bulletedText.count
            textView.selectedRange = NSRange(location: newCursorPosition, length: 0)
        } else {
            // Cursor only - modify current line
            let text = textView.text as NSString
            let currentPosition = selectedRange.location
            let lineRange = text.lineRange(for: NSRange(location: currentPosition, length: 0))
            
            // Create paragraph style with indentation
            let paragraphStyle = NSMutableParagraphStyle()
            paragraphStyle.headIndent = 15
            paragraphStyle.firstLineHeadIndent = 0
            paragraphStyle.paragraphSpacing = 4
            
            // Prepare for typing a bullet point
            var currentAttributes = textView.typingAttributes
            currentAttributes[.paragraphStyle] = paragraphStyle
            textView.typingAttributes = currentAttributes
            
            // Insert bullet at current position
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            let bulletText = "â€¢ "
            let bulletAttrs = textView.typingAttributes
            let bulletAttrString = NSAttributedString(string: bulletText, attributes: bulletAttrs)
            
            mutableAttrText.insert(bulletAttrString, at: currentPosition)
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            textView.selectedRange = NSRange(location: currentPosition + bulletText.count, length: 0)
        }
    }
    
    // Clear all formatting
    func clearFormatting() {
        guard let textView = textView else { return }
        let selectedRange = textView.selectedRange
        
        if selectedRange.length > 0 {
            // Clear formatting on selected text
            let mutableAttrText = NSMutableAttributedString(attributedString: attributedText)
            let plainText = mutableAttrText.string.substring(with: Range(selectedRange, in: mutableAttrText.string)!)
            
            // Create an attributed string with default attributes only
            let defaultFont = UIFont.preferredFont(forTextStyle: .body)
            let defaultAttributes: [NSAttributedString.Key: Any] = [
                .font: defaultFont,
                .foregroundColor: UIColor.label
            ]
            let plainAttrString = NSAttributedString(string: plainText, attributes: defaultAttributes)
            
            mutableAttrText.replaceCharacters(in: selectedRange, with: plainAttrString)
            
            attributedText = mutableAttrText
            textView.attributedText = mutableAttrText
            textView.selectedRange = NSRange(location: selectedRange.location, length: plainText.count)
            
            // Reset toolbar state
            formattingState.isBold = false
            formattingState.isItalic = false
            formattingState.isUnderlined = false
            formattingState.textColor = Color.primary
        } else {
            // Reset typing attributes for future input
            let defaultFont = UIFont.preferredFont(forTextStyle: .body)
            let defaultAttributes: [NSAttributedString.Key: Any] = [
                .font: defaultFont,
                .foregroundColor: UIColor.label
            ]
            textView.typingAttributes = defaultAttributes
            
            // Reset toolbar state
            formattingState.isBold = false
            formattingState.isItalic = false
            formattingState.isUnderlined = false
            formattingState.textColor = Color.primary
        }
    }
} # Add an empty line for separation
######NoteListView.swift###### /Users/rubenreut/Scribe/Scribe/View/NoteListView.swift
import SwiftUI
import SwiftData

/// List view showing all notes
struct NoteListView: View {
    var notes: [ScribeNote]
    @Binding var selectedNote: ScribeNote?
    var onDelete: (IndexSet) -> Void
    let viewModel: NoteViewModel
    
    @State private var showSettings = false
    @State private var showCreateFolder = false
    @State private var isOrganizing = false
    @State private var errorMessage: String? = nil
    @State private var showError = false
    
    // Folder management states
    @State private var selectedFolder: ScribeFolder? = nil
    @State private var showingFolderNotes = false
    @State private var folderToDelete: ScribeFolder? = nil
    @State private var showDeleteConfirmation = false
    @State private var deleteNotesWithFolder = false
    
    var body: some View {
        List(selection: $selectedNote) {
            // Folders section (if any)
            if !viewModel.folders.isEmpty {
                Section("Folders") {
                    ForEach(viewModel.folders) { folder in
                        HStack {
                            Image(systemName: folder.icon)
                                .foregroundColor(Color(folder.color))
                            Text(folder.name)
                            Spacer()
                            Text("\(folder.notes?.count ?? 0)")
                                .foregroundColor(.secondary)
                        }
                        .contentShape(Rectangle())
                        .onTapGesture {
                            showFolderNotes(folder)
                        }
                        .contextMenu {
                            Button {
                                showDeleteFolderConfirmation(folder)
                            } label: {
                                Label("Delete Folder", systemImage: "trash")
                            }
                        }
                    }
                }
            }
            
            // Notes section
            Section(header: Text(viewModel.folders.isEmpty ? "" : "Notes")) {
                ForEach(notes) { note in
                    NoteRowView(note: note, viewModel: viewModel)
                        .tag(note)
                        .id(note.id) // Ensure stable identity
                        .contextMenu {
                            Button(role: .destructive) {
                                if let index = notes.firstIndex(where: { $0.id == note.id }) {
                                    onDelete(IndexSet(integer: index))
                                }
                            } label: {
                                Label("Delete", systemImage: "trash")
                            }
                            
                            if note.folder != nil {
                                Button {
                                    viewModel.removeNoteFromFolder(note)
                                } label: {
                                    Label("Remove from Folder", systemImage: "folder.badge.minus")
                                }
                            } else {
                                // Add folder options for unorganized notes
                                Menu("Add to Folder") {
                                    ForEach(viewModel.folders) { folder in
                                        Button {
                                            viewModel.assignNote(note, toFolder: folder)
                                        } label: {
                                            Label(folder.name, systemImage: folder.icon)
                                        }
                                    }
                                    
                                    Button {
                                        showCreateFolder = true
                                    } label: {
                                        Label("New Folder...", systemImage: "folder.badge.plus")
                                    }
                                }
                            }
                        }
                }
                .onDelete(perform: onDelete)
            }
        }
        .listStyle(.sidebar)
        .navigationTitle("Notes")
        .scrollContentBackground(.visible)
        .accessibilityLabel("Notes list")
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Menu {
                    Button(action: viewModel.createNewNote) {
                        Label("New Note", systemImage: "square.and.pencil")
                    }
                    
                    Button {
                        Task {
                            isOrganizing = true
                            errorMessage = nil
                            let (success, error) = await viewModel.organizeNotesWithAI()
                            isOrganizing = false
                            
                            if !success, let errorMsg = error {
                                errorMessage = errorMsg
                                showError = true
                            }
                        }
                    } label: {
                        Label("Organize with AI", systemImage: "folder.badge.gearshape")
                    }
                    
                    Button {
                        showCreateFolder = true
                    } label: {
                        Label("New Folder", systemImage: "folder.badge.plus")
                    }
                    
                    Button {
                        showSettings = true
                    } label: {
                        Label("Settings", systemImage: "gear")
                    }
                } label: {
                    Image(systemName: "ellipsis.circle")
                }
            }
            
            ToolbarItem(placement: .navigationBarLeading) {
                Button(action: viewModel.createNewNote) {
                    Label("New", systemImage: "square.and.pencil")
                }
            }
        }
        .sheet(isPresented: $showSettings) {
            SettingsView()
        }
        .sheet(isPresented: $showCreateFolder) {
            CreateFolderView(viewModel: viewModel)
        }
        .overlay {
            if isOrganizing {
                FormatProgressView(message: "Organizing notes...")
            }
        }
        .alert("Organization Error", isPresented: $showError, presenting: errorMessage) { _ in
            Button("OK") { showError = false }
        } message: { error in
            Text(error)
        }
        .alert("Delete Folder", isPresented: $showDeleteConfirmation) {
            Button("Cancel", role: .cancel) {
                folderToDelete = nil
            }
            
            Button("Delete Only Folder", role: .destructive) {
                if let folder = folderToDelete {
                    viewModel.deleteFolder(folder, deleteNotes: false)
                    folderToDelete = nil
                }
            }
            
            Button("Delete Folder and Notes", role: .destructive) {
                if let folder = folderToDelete {
                    viewModel.deleteFolder(folder, deleteNotes: true)
                    folderToDelete = nil
                }
            }
        } message: {
            Text("Do you want to delete the folder '\(folderToDelete?.name ?? "")' and its notes, or just the folder?")
        }
        .sheet(isPresented: $showingFolderNotes, onDismiss: {
            selectedFolder = nil
        }) {
            if let folder = selectedFolder {
                FolderNotesView(folder: folder, viewModel: viewModel)
            }
        }
    }
}

// MARK: - Folder Actions

extension NoteListView {
    /// Shows the notes that are in a specific folder
    private func showFolderNotes(_ folder: ScribeFolder) {
        selectedFolder = folder
        showingFolderNotes = true
    }
    
    /// Shows the confirmation dialog for deleting a folder
    private func showDeleteFolderConfirmation(_ folder: ScribeFolder) {
        folderToDelete = folder
        showDeleteConfirmation = true
    }
}

struct NoteRowView: View {
    let note: ScribeNote
    let viewModel: NoteViewModel
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(note.title)
                    .font(.headline)
                    .lineLimit(1)
                    .accessibilityAddTraits(.isHeader)
                
                if note.folder != nil {
                    Spacer()
                    Image(systemName: "folder")
                        .foregroundColor(.secondary)
                        .font(.caption)
                }
            }
            
            Text(note.lastModified, style: .relative)
                .font(.caption)
                .foregroundColor(.secondary)
                .accessibilityLabel("Last edited \(note.lastModified.formatted())")
            
            Text(viewModel.attributedContent(for: note).string)
                .font(.caption)
                .foregroundColor(.secondary)
                .lineLimit(2)
                .accessibilityLabel("Note preview: \(viewModel.attributedContent(for: note).string)")
        }
        .padding(.vertical, 4)
    }
}

#Preview {
    @MainActor func createPreview() -> some View {
        let container = try! ModelContainer(for: ScribeNote.self, ScribeFolder.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))
        let modelContext = container.mainContext
        let viewModel = NoteViewModel(modelContext: modelContext)
        
        // Create an attributed string
        let attributedString = NSAttributedString(string: "This is sample content")
        
        // Create sample note with archived attributed string
        let sampleNote = ScribeNote(title: "Sample Note")
        if let data = try? NSKeyedArchiver.archivedData(withRootObject: attributedString, requiringSecureCoding: true) {
            sampleNote.content = data
        }
        modelContext.insert(sampleNote)
        
        return NoteListView(
            notes: [sampleNote],
            selectedNote: .constant(sampleNote),
            onDelete: { _ in },
            viewModel: viewModel
        )
        .modelContainer(container)
    }
    
    return createPreview()
} # Add an empty line for separation
######ImagePicker.swift###### /Users/rubenreut/Scribe/Scribe/View/ImagePicker.swift
import SwiftUI
import PhotosUI

struct ImagePicker: UIViewControllerRepresentable {
    @Environment(\.presentationMode) var presentationMode
    var completion: (UIImage) -> Void

    func makeUIViewController(context: Context) -> PHPickerViewController {
        var config = PHPickerConfiguration()
        config.filter = .images
        config.selectionLimit = 1
        let picker = PHPickerViewController(configuration: config)
        picker.delegate = context.coordinator
        return picker
    }

    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}

    func makeCoordinator() -> Coordinator {
        Coordinator(parent: self)
    }

    class Coordinator: NSObject, PHPickerViewControllerDelegate {
        var parent: ImagePicker

        init(parent: ImagePicker) {
            self.parent = parent
        }

        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
            picker.dismiss(animated: true)
            guard let provider = results.first?.itemProvider,
                  provider.canLoadObject(ofClass: UIImage.self) else { return }

            provider.loadObject(ofClass: UIImage.self) { image, _ in
                if let uiImage = image as? UIImage {
                    DispatchQueue.main.async {
                        self.parent.completion(uiImage)
                    }
                }
            }
        }
    }
} # Add an empty line for separation
######FolderNotesView.swift###### /Users/rubenreut/Scribe/Scribe/View/FolderNotesView.swift
import SwiftUI
import SwiftData

struct FolderNotesView: View {
    let folder: ScribeFolder
    let viewModel: NoteViewModel
    @Environment(\.dismiss) private var dismiss
    @State private var selectedNote: ScribeNote? = nil
    
    var body: some View {
        NavigationStack {
            VStack {
                if folderNotes.isEmpty {
                    ContentUnavailableView {
                        Label("No Notes", systemImage: "doc.text")
                    } description: {
                        Text("This folder doesn't contain any notes yet.")
                    }
                } else {
                    List(selection: $selectedNote) {
                        ForEach(folderNotes) { note in
                            NoteRowView(note: note, viewModel: viewModel)
                                .tag(note)
                                .contextMenu {
                                    Button {
                                        viewModel.removeNoteFromFolder(note)
                                        // Refresh view to update list
                                        refreshNotes()
                                    } label: {
                                        Label("Remove from Folder", systemImage: "folder.badge.minus")
                                    }
                                }
                        }
                    }
                    .listStyle(.inset)
                }
            }
            .navigationTitle(folder.name)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
            .sheet(item: $selectedNote) { note in
                RichTextNoteEditorView(selectedNote: .constant(note), viewModel: viewModel)
            }
        }
    }
    
    // Computed property for notes in this folder
    private var folderNotes: [ScribeNote] {
        viewModel.notesInFolder(folder)
    }
    
    // Refresh function to update the view when notes change
    private func refreshNotes() {
        // Force view refresh
        viewModel.refreshNotes()
    }
}

// Helper extension to make ScribeNote identifiable by wrapper
extension ScribeNote: Identifiable {
    public var id: String {
        return persistentModelID.storeIdentifier ?? UUID().uuidString
    }
}

#Preview {
    @MainActor func createPreview() -> some View {
        // Use the SwiftData preview container
        let config = ModelConfiguration(isStoredInMemoryOnly: true)
        let container = try! ModelContainer(for: ScribeNote.self, ScribeFolder.self, configurations: config)
        let modelContext = container.mainContext
        let viewModel = NoteViewModel(modelContext: modelContext)
        
        // Create a folder and some notes
        let folder = ScribeFolder(name: "Sample Folder")
        modelContext.insert(folder)
        
        // Create notes with archived attributed strings
        let attributedString = NSAttributedString(string: "This is sample content")
        
        for i in 1...3 {
            let note = ScribeNote(title: "Sample Note \(i)")
            if let data = try? NSKeyedArchiver.archivedData(withRootObject: attributedString, requiringSecureCoding: true) {
                note.content = data
            }
            note.folder = folder
            modelContext.insert(note)
        }
        
        return FolderNotesView(folder: folder, viewModel: viewModel)
            .modelContainer(container)
    }
    
    return createPreview()
} # Add an empty line for separation
######CreateFolderView.swift###### /Users/rubenreut/Scribe/Scribe/View/CreateFolderView.swift
import SwiftUI
import SwiftData

struct CreateFolderView: View {
    @Environment(\.dismiss) private var dismiss
    let viewModel: NoteViewModel
    
    @State private var folderName = ""
    @State private var selectedColor = UIColor.systemBlue
    @State private var selectedIcon = "folder"
    
    private let availableIcons = [
        "folder", "folder.fill", "doc.on.doc", "tray", "archivebox",
        "book.closed", "magazine", "note.text", "doc.text", "briefcase",
        "star", "tag", "bookmark", "paperclip"
    ]
    
    private let availableColors: [UIColor] = [
        .systemBlue, .systemRed, .systemGreen, .systemPurple, .systemOrange,
        .systemTeal, .systemPink, .systemIndigo, .systemYellow, .systemGray
    ]
    
    var body: some View {
        NavigationView {
            Form {
                Section {
                    TextField("Folder Name", text: $folderName)
                        .autocapitalization(.words)
                }
                
                Section(header: Text("Icon")) {
                    LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 7), spacing: 10) {
                        ForEach(availableIcons, id: \.self) { icon in
                            Image(systemName: icon)
                                .font(.title2)
                                .foregroundColor(selectedIcon == icon ? Color(selectedColor) : .gray)
                                .padding(8)
                                .background(
                                    selectedIcon == icon ?
                                    Color(selectedColor).opacity(0.2) :
                                    Color.clear
                                )
                                .clipShape(Circle())
                                .onTapGesture {
                                    selectedIcon = icon
                                }
                        }
                    }
                    .padding(.vertical, 8)
                }
                
                Section(header: Text("Color")) {
                    LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 5), spacing: 10) {
                        ForEach(0..<availableColors.count, id: \.self) { index in
                            let color = availableColors[index]
                            Circle()
                                .fill(Color(color))
                                .frame(width: 32, height: 32)
                                .overlay(
                                    Circle()
                                        .stroke(Color.white, lineWidth: selectedColor == color ? 2 : 0)
                                )
                                .padding(4)
                                .background(
                                    Circle()
                                        .fill(selectedColor == color ? Color(color).opacity(0.3) : Color.clear)
                                )
                                .onTapGesture {
                                    selectedColor = color
                                }
                        }
                    }
                    .padding(.vertical, 8)
                }
            }
            .navigationTitle("New Folder")
            .navigationBarItems(
                leading: Button("Cancel") {
                    dismiss()
                },
                trailing: Button("Create") {
                    createFolder()
                    dismiss()
                }
                .disabled(folderName.isEmpty)
            )
        }
    }
    
    private func createFolder() {
        guard !folderName.isEmpty else { return }
        
        // Create the folder using ViewModel
        let folder = viewModel.createFolder(
            name: folderName, 
            icon: selectedIcon, 
            color: selectedColor
        )
        
        // A real implementation would now select this folder or show its contents
    }
}

struct CreateFolderView_Previews: PreviewProvider {
    static var previews: some View {
        @MainActor func createPreview() -> some View {
            let container = try! ModelContainer(for: ScribeNote.self, ScribeFolder.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))
            let modelContext = container.mainContext
            let viewModel = NoteViewModel(modelContext: modelContext)
            
            return CreateFolderView(viewModel: viewModel)
        }
        
        return createPreview()
    }
}
 # Add an empty line for separation
######AttachmentMenu.swift###### /Users/rubenreut/Scribe/Scribe/View/AttachmentMenu.swift
import SwiftUI
import UniformTypeIdentifiers
import PhotosUI

/// A menu for attaching different types of content to notes
struct AttachmentMenu: View {
    @Binding var showImagePicker: Bool
    @Binding var showDocumentPicker: Bool
    
    var body: some View {
        Menu {
            Button(action: { showImagePicker = true }) {
                Label("Photo", systemImage: "photo")
            }
            
            Button(action: { showDocumentPicker = true }) {
                Label("Document", systemImage: "doc")
            }
            
            // Camera option - would require camera permission handling
            Button(action: { /* Camera handling would go here */ }) {
                Label("Camera", systemImage: "camera")
            }
            
            // Scan document option
            Button(action: { /* Document scanning would go here */ }) {
                Label("Scan Document", systemImage: "doc.viewfinder")
            }
        } label: {
            Image(systemName: "paperclip")
                .font(.system(size: 17, weight: .semibold))
                .frame(width: 34, height: 34)
                .background(Color.secondary.opacity(0.1))
                .clipShape(Circle())
        }
    }
}

// Preview provider for design-time preview
struct AttachmentMenu_Previews: PreviewProvider {
    static var previews: some View {
        AttachmentMenu(
            showImagePicker: .constant(false),
            showDocumentPicker: .constant(false)
        )
        .previewLayout(.sizeThatFits)
        .padding()
    }
} # Add an empty line for separation
######FormatMenu.swift###### /Users/rubenreut/Scribe/Scribe/View/FormatMenu.swift
import SwiftUI

/// A modern formatting menu for the rich text editor
struct FormatMenu: View {
    @ObservedObject var formattingState: FormattingState
    let onFormat: (FormatAction) -> Void
    
    // Available formatting actions
    enum FormatAction {
        case bold
        case italic
        case underline
        case heading(Font.TextStyle)
        case textColor
        case bulletList
        case clearFormatting
    }
    
    var body: some View {
        Menu {
            // Text style section
            Section {
                Button(action: { onFormat(.bold) }) {
                    Label("Bold", systemImage: "bold")
                }
                .foregroundColor(formattingState.isBold ? .accentColor : nil)
                
                Button(action: { onFormat(.italic) }) {
                    Label("Italic", systemImage: "italic")
                }
                .foregroundColor(formattingState.isItalic ? .accentColor : nil)
                
                Button(action: { onFormat(.underline) }) {
                    Label("Underline", systemImage: "underline")
                }
                .foregroundColor(formattingState.isUnderlined ? .accentColor : nil)
            }
            
            // Headings section
            Section {
                Button(action: { onFormat(.heading(.title)) }) {
                    Label("Heading", systemImage: "textformat.size.larger")
                }
                
                Button(action: { onFormat(.heading(.headline)) }) {
                    Label("Subheading", systemImage: "textformat.size")
                }
                
                Button(action: { onFormat(.heading(.body)) }) {
                    Label("Body Text", systemImage: "text.justify")
                }
            }
            
            // Other formatting section
            Section {
                Button(action: { onFormat(.textColor) }) {
                    Label("Text Color", systemImage: "paintpalette")
                }
                
                Button(action: { onFormat(.bulletList) }) {
                    Label("Bullet List", systemImage: "list.bullet")
                }
                
                Button(action: { onFormat(.clearFormatting) }) {
                    Label("Clear Formatting", systemImage: "eraser")
                }
            }
        } label: {
            Image(systemName: "textformat")
                .font(.system(size: 17, weight: .semibold))
                .frame(width: 34, height: 34)
                .background(Color.secondary.opacity(0.1))
                .clipShape(Circle())
        }
    }
}

// Preview provider for design-time preview
struct FormatMenu_Previews: PreviewProvider {
    static var previews: some View {
        FormatMenu(
            formattingState: FormattingState(),
            onFormat: { _ in }
        )
        .previewLayout(.sizeThatFits)
        .padding()
    }
} # Add an empty line for separation
######ScribeApp.swift###### /Users/rubenreut/Scribe/Scribe/ScribeApp.swift
//
//  ScribeApp.swift
//  Scribe
//
//  Created by Ruben Reut on 14/04/2025.
//

import SwiftUI
import SwiftData
import OSLog
import Foundation

/// Main application entry point
@main
struct ScribeApp: App {
    private let logger = Logger(subsystem: "com.rubenreut.Scribe", category: "Application")
    
    init() {
        configureLogger()
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                // No need to log every view appearance
        }
        .modelContainer(for: [ScribeNote.self, ScribeFolder.self])
        .commands {
            // Add app-specific commands
            CommandGroup(after: .newItem) {
                Button("New Note") {
                    NotificationCenter.default.post(name: Constants.NotificationNames.createNewNote, object: nil)
                }
                .keyboardShortcut("n", modifiers: [.command])
            }
        }
    }
    
    /// Configures application-wide logging
    private func configureLogger() {
        #if DEBUG
        // More verbose in debug builds
        // Debug logging enabled
        #endif
    }
}

 # Add an empty line for separation
######ContentView.swift###### /Users/rubenreut/Scribe/Scribe/ContentView.swift
//
//  ContentView.swift
//  Scribe
//
//  Created by Ruben Reut on 14/04/2025.
//

import SwiftUI
import SwiftData
import Foundation

/// Main content view showing split navigation between note list and editor
struct ContentView: View {
    @Environment(\.modelContext) private var modelContext
    @State private var viewModel: NoteViewModel
    // Always use rich text - remove toggle functionality
    private let useRichText: Bool = true
    
    init() {
        // This will be properly initialized when the @Environment is available
        do {
            let container = try ModelContainer(for: ScribeNote.self)
            _viewModel = State(initialValue: NoteViewModel(modelContext: ModelContext(container)))
        } catch {
            fatalError("Failed to create model container: \(error.localizedDescription)")
        }
    }
    
    var body: some View {
        NavigationSplitView {
            VStack {
                NoteListView(
                    notes: viewModel.filteredNotes,
                    selectedNote: $viewModel.selectedNote,
                    onDelete: viewModel.deleteNotes,
                    viewModel: viewModel
                )
                .searchable(text: $viewModel.searchText, prompt: "Search notes...")
                .navigationTitle("Notes")
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button(action: viewModel.createNewNote) {
                            Label("New Note", systemImage: "square.and.pencil")
                                .accessibilityLabel("Create a new note")
                        }
                    }
                    
                    
                    // Rich text toggle button removed - always using rich text editor
                }
            }
        } detail: {
            // Only show the rich text editor
            RichTextNoteEditorView(selectedNote: $viewModel.selectedNote, viewModel: viewModel)
        }
        .navigationSplitViewStyle(.balanced)
        .task {
            // Replace the temporary context with the real one
            viewModel = NoteViewModel(modelContext: modelContext)
            
            // Refresh notes asynchronously to ensure proper initialization
            await Task { @MainActor in
                // Brief pause to ensure model context is fully ready
                try? await Task.sleep(nanoseconds: 100_000_000) // 100ms
                viewModel.refreshNotes()
            }.value
        }
        .onReceive(NotificationCenter.default.publisher(for: Constants.NotificationNames.createNewNote)) { _ in
            viewModel.createNewNote()
        }
    }
}

#Preview {
    @MainActor func createPreview() -> some View {
        let container = try! ModelContainer(for: ScribeNote.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))
        
        return ContentView()
            .modelContainer(container)
    }
    
    return createPreview()
}
 # Add an empty line for separation
######AIService.swift###### /Users/rubenreut/Scribe/Scribe/Services/AIService.swift
import Foundation
import SwiftUI

class AIService {
    private let apiKey: String
    private let baseURL: URL
    
    enum AIProvider: String {
        case openAI = "OpenAI"
        case claude = "Claude"
    }
    
    init(apiKey: String, provider: AIProvider = .openAI) {
        self.apiKey = apiKey
        
        switch provider {
        case .openAI:
            self.baseURL = URL(string: Constants.API.openAIBaseURL)!
        case .claude:
            // Would implement different base URL for Claude
            self.baseURL = URL(string: Constants.API.openAIBaseURL)!
        }
    }
    
    // MARK: - Note Organization
    
    func organizeNotes(_ notes: [ScribeNote], existingFolders: [ScribeFolder]) async throws -> [NoteOrganization] {
        // Prepare API request with notes content and existing folders
        let prompt = createOrganizationPrompt(notes, existingFolders)
        let response = try await sendRequest(prompt: prompt)
        
        // Parse response into note organizations
        return try parseOrganizationResponse(response, notes: notes)
    }
    
    private func createOrganizationPrompt(_ notes: [ScribeNote], _ folders: [ScribeFolder]) -> String {
        // Create a prompt that includes all notes and existing folders
        var prompt = "Organize the following notes into folders. You can suggest existing folders or create new ones. Respond in JSON format.\n\nExisting folders:\n"
        
        for (index, folder) in folders.enumerated() {
            prompt += "\(index + 1). \(folder.name)\n"
        }
        
        if folders.isEmpty {
            prompt += "(No existing folders yet)\n"
        }
        
        prompt += "\nNotes to organize:\n"
        
        for (index, note) in notes.enumerated() {
            let content: String
            do {
                // Register necessary classes for secure coding
                NSKeyedUnarchiver.setClass(NSTextAttachment.self, forClassName: "NSTextAttachment")
                NSKeyedUnarchiver.setClass(UIImage.self, forClassName: "UIImage")
                
                content = (try NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(note.content) as? NSAttributedString)?.string ?? ""
            } catch {
                content = "Error retrieving content"
                print("Failed to unarchive note content: \(error)")
            }
            
            let safeContent = content.prefix(100)
            prompt += "Note \(index): Index: \(index), Title: \(note.title), Content: \(safeContent)...\n\n"
        }
        
        prompt += """

        Respond with a JSON array where each object has the following properties:
        - 'noteIndex': The index of the note (integer, using the index provided above)
        - 'folderName': Name of the folder to place the note in (string)
        - 'isNewFolder': true if this is a new folder to create, false if using existing folder (boolean)
        
        Example response:
        [
          {
            "noteIndex": 0,
            "folderName": "Work Notes",
            "isNewFolder": true
          },
          {
            "noteIndex": 1,
            "folderName": "Personal",
            "isNewFolder": true
          }
        ]
        """
        
        // Print prompt for debugging
        print("AI Organization Prompt: \(prompt)")
        
        return prompt
    }
    
    private func parseOrganizationResponse(_ response: String, notes: [ScribeNote]) throws -> [NoteOrganization] {
        // Parse JSON response into NoteOrganization structs
        print("API Response to parse: \(response)")
        
        guard let jsonData = response.data(using: .utf8) else {
            print("Failed to convert response to data")
            throw AIServiceError.invalidResponseFormat
        }
        
        // Try to extract JSON array if the response contains extra text
        if let startIndex = response.firstIndex(of: "["), 
           let endIndex = response.lastIndex(of: "]"), 
           startIndex < endIndex {
            let jsonSubstring = response[startIndex...endIndex]
            let cleanJsonData = Data(jsonSubstring.utf8)
            
            do {
                let decoder = JSONDecoder()
                let organizationResults = try decoder.decode([NoteOrganizationResult].self, from: cleanJsonData)
                
                print("Successfully decoded \(organizationResults.count) organization results")
                return organizationResults.compactMap { result in
                    guard result.noteIndex >= 0, result.noteIndex < notes.count else { 
                        print("Invalid note index: \(result.noteIndex)")
                        return nil 
                    }
                    return NoteOrganization(
                        note: notes[result.noteIndex], 
                        folderName: result.folderName, 
                        isNewFolder: result.isNewFolder
                    )
                }
            } catch {
                print("Failed to decode extracted JSON: \(error)")
                // Fallback to original parsing if substring extraction fails
            }
        }
        
        // Attempt standard parsing
        do {
            let decoder = JSONDecoder()
            let organizationResults = try decoder.decode([NoteOrganizationResult].self, from: jsonData)
            
            print("Successfully decoded \(organizationResults.count) organization results")
            return organizationResults.compactMap { result in
                guard result.noteIndex >= 0, result.noteIndex < notes.count else { 
                    print("Invalid note index: \(result.noteIndex)")
                    return nil 
                }
                return NoteOrganization(
                    note: notes[result.noteIndex], 
                    folderName: result.folderName, 
                    isNewFolder: result.isNewFolder
                )
            }
        } catch {
            print("JSON Parsing error: \(error)")
            
            // Try to extract JSON as a string from response if it might be mixed with other content
            if let jsonStart = response.range(of: "```json"), 
               let jsonEnd = response.range(of: "```", range: jsonStart.upperBound..<response.endIndex) {
                let jsonSubstring = response[jsonStart.upperBound..<jsonEnd.lowerBound].trimmingCharacters(in: .whitespacesAndNewlines)
                
                print("Found code block with possible JSON: \(jsonSubstring)")
                if let jsonData = jsonSubstring.data(using: .utf8) {
                    do {
                        let decoder = JSONDecoder()
                        let organizationResults = try decoder.decode([NoteOrganizationResult].self, from: jsonData)
                        
                        print("Successfully decoded JSON from code block")
                        return organizationResults.compactMap { result in
                            guard result.noteIndex >= 0, result.noteIndex < notes.count else { return nil }
                            return NoteOrganization(
                                note: notes[result.noteIndex], 
                                folderName: result.folderName, 
                                isNewFolder: result.isNewFolder
                            )
                        }
                    } catch {
                        print("Failed to decode JSON from code block: \(error)")
                    }
                }
            }
            
            throw AIServiceError.invalidResponseFormat
        }
    }
    
    // MARK: - API Testing
    
    /// Tests the API connection with a simple request
    func testConnection(prompt: String) async throws -> String {
        return try await sendRequest(prompt: prompt)
    }
    
    // MARK: - Note Formatting
    
    func formatNoteContent(_ content: String) async throws -> FormattedContent {
        // Prepare API request with note content
        let prompt = createFormattingPrompt(content)
        let response = try await sendRequest(prompt: prompt)
        
        // Parse response into formatted content instructions
        return try parseFormattingResponse(response, originalContent: content)
    }
    
    private func createFormattingPrompt(_ content: String) -> String {
        return """
        Format the following note content with appropriate headings, subheadings, and bullet points. 
        Do not change the actual content - only add formatting.
        Respond with a JSON object containing format instructions.
        
        Note content:
        \(content)
        
        Example response format:
        {
          "instructions": [
            {"type": "heading", "text": "Meeting Notes", "level": 1},
            {"type": "paragraph", "text": "Discussion about project timeline."},
            {"type": "bulletList", "items": ["Task 1", "Task 2"]}
          ]
        }
        """
    }
    
    private func parseFormattingResponse(_ response: String, originalContent: String) throws -> FormattedContent {
        // Parse JSON response into formatting instructions
        guard let jsonData = response.data(using: .utf8) else {
            throw AIServiceError.invalidResponseFormat
        }
        
        let decoder = JSONDecoder()
        return try decoder.decode(FormattedContent.self, from: jsonData)
    }
    
    // MARK: - API Request
    
    private func sendRequest(prompt: String) async throws -> String {
        var request = URLRequest(url: baseURL)
        request.httpMethod = "POST"
        request.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Print debug info but mask the API key
        print("ðŸ“¡ Sending request to: \(baseURL)")
        print("ðŸ”‘ Using API key: \(String(apiKey.prefix(3)))...\(String(apiKey.suffix(3)))")
        
        let requestBody: [String: Any] = [
            "model": "gpt-4",
            "messages": [
                ["role": "system", "content": "You are a helpful assistant for organizing and formatting notes."],
                ["role": "user", "content": prompt]
            ],
            "temperature": 0.3
        ]
        
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
        
        do {
            print("â³ Waiting for API response...")
            let (data, response) = try await URLSession.shared.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse else {
                print("âŒ Invalid HTTP response")
                throw AIServiceError.networkError
            }
            
            print("ðŸ“¥ Received response with status code: \(httpResponse.statusCode)")
            
            guard httpResponse.statusCode == 200 else {
                let errorBody = String(data: data, encoding: .utf8) ?? "Unknown error"
                print("âš ï¸ API error (\(httpResponse.statusCode)): \(errorBody)")
                throw AIServiceError.apiError(statusCode: httpResponse.statusCode, message: errorBody)
            }
            
            do {
                let responseDict = try JSONSerialization.jsonObject(with: data) as? [String: Any]
                let choices = responseDict?["choices"] as? [[String: Any]]
                let firstChoice = choices?.first
                let message = firstChoice?["message"] as? [String: Any]
                
                guard let content = message?["content"] as? String else {
                    print("âŒ Invalid response format: \(String(data: data, encoding: .utf8) ?? "<unreadable data>")")
                    throw AIServiceError.invalidResponseFormat
                }
                
                print("âœ… Successfully parsed API response")
                return content
            } catch {
                print("âŒ JSON parsing error: \(error)")
                print("ðŸ“„ Response data: \(String(data: data, encoding: .utf8) ?? "<unreadable data>")")
                throw AIServiceError.invalidResponseFormat
            }
        } catch {
            print("âŒ Network or parsing error: \(error)")
            throw error
        }
    }
}

// MARK: - Models for organization and formatting

struct NoteOrganizationResult: Decodable {
    let noteIndex: Int
    let folderName: String
    let isNewFolder: Bool
}

struct NoteOrganization {
    let note: ScribeNote
    let folderName: String
    let isNewFolder: Bool
}

struct FormattedContent: Decodable {
    let instructions: [FormatInstruction]
}

enum FormatInstruction: Decodable {
    case heading(text: String, level: Int)
    case paragraph(text: String)
    case bulletList(items: [String])
    
    enum CodingKeys: String, CodingKey {
        case type, text, level, items
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)
        
        switch type {
        case "heading":
            let text = try container.decode(String.self, forKey: .text)
            let level = try container.decode(Int.self, forKey: .level)
            self = .heading(text: text, level: level)
        case "paragraph":
            let text = try container.decode(String.self, forKey: .text)
            self = .paragraph(text: text)
        case "bulletList":
            let items = try container.decode([String].self, forKey: .items)
            self = .bulletList(items: items)
        default:
            throw DecodingError.dataCorruptedError(
                forKey: .type,
                in: container,
                debugDescription: "Invalid format instruction type"
            )
        }
    }
}

enum AIServiceError: Error {
    case networkError
    case apiError(statusCode: Int, message: String)
    case invalidResponseFormat
    case missingAPIKey
}

extension AIServiceError: LocalizedError {
    var errorDescription: String? {
        switch self {
        case .networkError:
            return "Network error occurred. Please check your internet connection."
        case .apiError(let statusCode, let message):
            return "API error (Status \(statusCode)): \(message)"
        case .invalidResponseFormat:
            return "Invalid response format from the API."
        case .missingAPIKey:
            return "API key is missing. Please set it in Settings."
        }
    }
}
 # Add an empty line for separation
